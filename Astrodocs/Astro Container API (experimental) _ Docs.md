- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
								
							
							
	



						
						
	
				
						Pages
						
					
			
				
						Routing
						
					
			
				
						Endpoints
						
					
			
				
						Middleware
						
					
			
				
						Internationalization (i18n)
						
					
			
				
						Prefetch
						
					
			
				
						View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
								
							
							
	



						
						
	
				
						Components
						
					
			
				
						Layouts
						
					
			
				
						Styles and CSS
						
					
			
				
						Fonts
						
					
			
				
						Syntax Highlighting
						
					
			
				
						Scripts and event handling
						
					
			
				
						Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
								
							
							
	



						
						
	
				
						Markdown
						
					
			
				
						Content collections
						
					
			
				
						Images
						
					
			
				
						Data fetching
						
					
			
				
						Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
								
							
							
	



						
						
	
				
						On-demand rendering
						
					
			
				
						Server islands
						
					
			
				
						Actions
						
					
			
				
						Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
								
							
							
	



						
						
	
				
						Upgrade Astro
						
					
			
				
						
						
							
								Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- Upgrade Astro
- Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- v5.0
- v4.0
- v3.0
- v2.0
- v1.0
- Troubleshooting
- How-to recipes
								
							
							
	



						
						
	
				
						Recipes overview
						
					
			
				
						Installing a Vite or Rollup plugin
						
					
			
				
						Analyze bundle size
						
					
			
				
						Build a custom image component
						
					
			
				
						Build HTML forms in Astro pages
						
					
			
				
						Build forms with API routes
						
					
			
				
						Use Bun with Astro
						
					
			
				
						Call endpoints from the server
						
					
			
				
						Verify a Captcha
						
					
			
				
						Customize file names in the build output
						
					
			
				
						Build your Astro site with Docker
						
					
			
				
						Dynamically import images
						
					
			
				
						Add icons to external links
						
					
			
				
						Add i18n features
						
					
			
				
						Create a dev toolbar app
						
					
			
				
						Add last modified time
						
					
			
				
						Add reading time
						
					
			
				
						Add an RSS feed
						
					
			
				
						Share state between Astro components
						
					
			
				
						Share state between islands
						
					
			
				
						Using streaming to improve page performance
						
					
			
				
						Style rendered Markdown with Tailwind Typography
- Recipes overview
- Installing a Vite or Rollup plugin
- Analyze bundle size
- Build a custom image component
- Build HTML forms in Astro pages
- Build forms with API routes
- Use Bun with Astro
- Call endpoints from the server
- Verify a Captcha
- Customize file names in the build output
- Build your Astro site with Docker
- Dynamically import images
- Add icons to external links
- Add i18n features
- Create a dev toolbar app
- Add last modified time
- Add reading time
- Add an RSS feed
- Share state between Astro components
- Share state between islands
- Using streaming to improve page performance
- Style rendered Markdown with Tailwind Typography
- Contribute to Astro
- Astro Template Syntax
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
Render context
astro:actions
astro:assets
astro:config
astro:content
astro:env
astro:i18n
astro:middleware
astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
Integration API
Adapter API
Content Loader API
Image Service API
Dev Toolbar App API
Container API (experimental)
Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
Configuring experimental flags
Content Security Policy
Fonts
Live content collections
Client prerendering
Intellisense for collections
Preserve scripts order
Markdown heading ID compatibility
Private meta environment variables inlining
Chrome DevTools workspace
Prerender conflict error
SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- create()
				
				
	
				
					streaming option
				
				
			
				
					renderers option
- streaming option
- renderers option
- renderToString()
- renderToResponse()
- Rendering options
				
				
	
				
					slots
				
				
			
				
					props option
				
				
			
				
					request option
				
				
			
				
					params option
				
				
			
				
					locals options
				
				
			
				
					routeType option
				
				
			
				
					partial option
- slots
- props option
- request option
- params option
- locals options
- routeType option
- partial option
## On this page

- Overview
- create()
streaming option
renderers option
- streaming option
- renderers option
- renderToString()
- renderToResponse()
- Rendering options
slots
props option
request option
params option
locals options
routeType option
partial option
- slots
- props option
- request option
- params option
- locals options
- routeType option
- partial option
## Learn Astro with Coding in Public

150+ video lessons
•
Astro v5 ready

# Astro Container API (experimental)

Added in: astro@4.9.0

```
astro@4.9.0
```

The Container API allows you to render Astro components in isolation.

This experimental server-side API unlocks a variety of potential future uses, but is currently scoped to allow testing of .astro component output in vite environments such as vitest.

```
.astro
```

```
vite
```

```
vitest
```

It also allows you to manually load rendering scripts for creating containers in pages rendered on demand or other “shell” environments outside of vite (e.g. inside a PHP or Elixir application).

```
vite
```

This API allows you to create a new container, and render an Astro component returning a string or a Response.

```
Response
```

This API is experimental and subject to breaking changes, even in minor or patch releases. Please consult the Astro CHANGELOG for changes as they occur. This page will always be updated with the most current information for the latest version of Astro.

## create()

```
create()
```

Type: (options?: AstroContainerOptions) => Promise<experimental_AstroContainer>

```
(options?: AstroContainerOptions) => Promise<experimental_AstroContainer>
```

Creates a new instance of the container.

```
import { experimental_AstroContainer } from "astro/container";


const container = await experimental_AstroContainer.create();
```

```
import { experimental_AstroContainer } from "astro/container";


const container = await experimental_AstroContainer.create();
```

It accepts an object with the following options:

```
export type AstroContainerOptions = {
  streaming?: boolean;
  renderers?: AddServerRenderer[];
};


export type AddServerRenderer =
  | {
      renderer: NamedSSRLoadedRendererValue;
      name: never;
    }
  | {
      renderer: SSRLoadedRendererValue;
      name: string;
    };
```

```
export type AstroContainerOptions = {
  streaming?: boolean;
  renderers?: AddServerRenderer[];
};


export type AddServerRenderer =
  | {
      renderer: NamedSSRLoadedRendererValue;
      name: never;
    }
  | {
      renderer: SSRLoadedRendererValue;
      name: string;
    };
```

### streaming option

```
streaming
```

Type: boolean
Default: false

```
boolean
```

```
false
```

Enables rendering components using HTML streaming.

### renderers option

```
renderers
```

Type: AddServerRenderer[]
Default: []

```
AddServerRenderer[]
```

```
[]
```

A list of loaded client renderers required by the component. Use this if your .astro component renders any UI framework components or MDX using an official Astro integration (e.g. React, Vue, etc.).

```
.astro
```

Renderers can be added through the Container API automatically for static applications, or cases where the container isn’t called at runtime (e.g. testing with vitest).

```
vitest
```

For on-demand rendered applications, or cases where the container is called at runtime or inside other “shells” (e.g. PHP, Ruby, Java, etc.), renderers must be manually imported.

#### Adding a renderer through the Container API

For each official Astro integration, import and use the getContainerRenderer() helper function to expose its client and server rendering scripts. These are available for @astrojs/react, @astrojs/preact, @astrojs/solid-js, @astrojs/svelte, @astrojs/vue, and @astrojs/mdx.

```
getContainerRenderer()
```

```
@astrojs/react
```

```
@astrojs/preact
```

```
@astrojs/solid-js
```

```
@astrojs/svelte
```

```
@astrojs/vue
```

```
@astrojs/mdx
```

For renderer packages outside the @astrojs npm org, look in their documentation for getContainerRenderer() or a similar function provided.

```
@astrojs
```

```
getContainerRenderer()
```

When using vite (vitest, Astro integrations, etc.), the renderers are loaded with the function loadRenderers() from the virtual module astro:container.

```
vite
```

```
vitest
```

```
loadRenderers()
```

```
astro:container
```

Caution

Outside vite or for on-demand usage, you’ll have to load the renderers manually.

```
vite
```

The following example provides the necessary object to render an Astro component that renders a React component and a Svelte component:

```
import { getContainerRenderer as reactContainerRenderer } from "@astrojs/react";
import { getContainerRenderer as svelteContainerRenderer } from "@astrojs/svelte";
import { loadRenderers } from "astro:container";


const renderers = await loadRenderers([reactContainerRenderer(), svelteContainerRenderer()]);
const container = await experimental_AstroContainer.create({
    renderers
})
const result = await container.renderToString(ReactWrapper);
```

```
import { getContainerRenderer as reactContainerRenderer } from "@astrojs/react";
import { getContainerRenderer as svelteContainerRenderer } from "@astrojs/svelte";
import { loadRenderers } from "astro:container";


const renderers = await loadRenderers([reactContainerRenderer(), svelteContainerRenderer()]);
const container = await experimental_AstroContainer.create({
    renderers
})
const result = await container.renderToString(ReactWrapper);
```

#### Adding a renderer manually

When the container is called at runtime, or inside other “shells”, the astro:container virtual module’s helper functions are not available. You must import the necessary server and client renderers manually and store them inside the container using addServerRenderer and addClientRenderer.

```
astro:container
```

```
addServerRenderer
```

```
addClientRenderer
```

Server renderers are required to build your project, and must be stored in the container for every framework used. Client renderers are additionally needed to any hydrate client-side components using client:* directives.

```
client:*
```

Only one import statement is needed per framework. Importing a renderer makes both the server and client renderers available to your container. However, server renderers must be added to your container before client renderers. This allows your entire container to render first, and then hydrate any interactive components.

The following example manually imports the necessary server renderers to be able to display static Vue components and .mdx pages. It additionally adds both server and client renderers for interactive React components.

```
.mdx
```

```
import reactRenderer from "@astrojs/react/server.js";
import vueRenderer from "@astrojs/vue/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";


const container = await experimental_AstroContainer.create();
container.addServerRenderer({ renderer: vueRenderer });
container.addServerRenderer({ renderer: mdxRenderer });


container.addServerRenderer({ renderer: reactRenderer });
container.addClientRenderer({ name: "@astrojs/react", entrypoint: "@astrojs/react/client.js" });
```

```
import reactRenderer from "@astrojs/react/server.js";
import vueRenderer from "@astrojs/vue/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";


const container = await experimental_AstroContainer.create();
container.addServerRenderer({ renderer: vueRenderer });
container.addServerRenderer({ renderer: mdxRenderer });


container.addServerRenderer({ renderer: reactRenderer });
container.addClientRenderer({ name: "@astrojs/react", entrypoint: "@astrojs/react/client.js" });
```

## renderToString()

```
renderToString()
```

Type: (component: AstroComponentFactory; options?: ContainerRenderOptions) => Promise<string>

```
(component: AstroComponentFactory; options?: ContainerRenderOptions) => Promise<string>
```

This function renders a specified component inside a container. It takes an Astro component as an argument and it returns a string that represents the HTML/content rendered by the Astro component.

```
import { experimental_AstroContainer } from "astro/container";
import Card from "../src/components/Card.astro";


const container = await experimental_AstroContainer.create();
const result = await container.renderToString(Card);
```

```
import { experimental_AstroContainer } from "astro/container";
import Card from "../src/components/Card.astro";


const container = await experimental_AstroContainer.create();
const result = await container.renderToString(Card);
```

Under the hood, this function calls renderToResponse() and Response.text().

```
renderToResponse()
```

```
Response.text()
```

It also accepts an object as a second argument that can contain a number of options.

## renderToResponse()

```
renderToResponse()
```

Type: (component: AstroComponentFactory; options?: ContainerRenderOptions) => Promise<Response>

```
(component: AstroComponentFactory; options?: ContainerRenderOptions) => Promise<Response>
```

It renders a component, and it returns a Response object.

```
Response
```

```
import { experimental_AstroContainer } from "astro/container";
import Card from "../src/components/Card.astro";


const container = await experimental_AstroContainer.create();
const result = await container.renderToResponse(Card);
```

```
import { experimental_AstroContainer } from "astro/container";
import Card from "../src/components/Card.astro";


const container = await experimental_AstroContainer.create();
const result = await container.renderToResponse(Card);
```

It also accepts an object as a second argument that can contain a number of options.

## Rendering options

Both renderToResponse() and renderToString() accept an object as their second argument:

```
renderToResponse()
```

```
renderToString()
```

```
export type ContainerRenderOptions = {
  slots?: Record<string, any>;
  props?: Record<string, unknown>;
  request?: Request;
  params?: Record<string, string | undefined>;
  locals?: App.Locals;
  routeType?: RouteType;
  partial?: boolean;
};
```

```
export type ContainerRenderOptions = {
  slots?: Record<string, any>;
  props?: Record<string, unknown>;
  request?: Request;
  params?: Record<string, string | undefined>;
  locals?: App.Locals;
  routeType?: RouteType;
  partial?: boolean;
};
```

These optional values can be passed to the rendering function in order to provide additional information necessary for an Astro component to properly render.

### slots

```
slots
```

Type: Record<string, any>

```
Record<string, any>
```

An option to pass content to be rendered with <slots>.

```
<slots>
```

If your Astro component renders one default slot, pass an object with default as the key:

```
default
```

```
import Card from "../src/components/Card.astro";


const result = await container.renderToString(Card, {
  slots: { default: "Some value" }
});
```

```
import Card from "../src/components/Card.astro";


const result = await container.renderToString(Card, {
  slots: { default: "Some value" }
});
```

If your component renders named slots, use the slot names as the object keys:

```
---
---
<div>
  <slot name="header" />
  <slot name="footer" />
</div>
```

```
---
---
<div>
  <slot name="header" />
  <slot name="footer" />
</div>
```

```
import Card from "../src/components/Card.astro";


const result = await container.renderToString(Card, {
  slots: {
    header: "Header content",
    footer: "Footer"
  }
});
```

```
import Card from "../src/components/Card.astro";


const result = await container.renderToString(Card, {
  slots: {
    header: "Header content",
    footer: "Footer"
  }
});
```

You can also render components in cascade:

```
---
---
<div>
  <slot name="header" />
  <slot name="footer" />
</div>
```

```
---
---
<div>
  <slot name="header" />
  <slot name="footer" />
</div>
```

```
import Card from "../src/components/Card.astro";
import CardHeader from "../src/components/CardHeader.astro";
import CardFooter from "../src/components/CardFooter.astro";


const result = await container.renderToString(Card, {
  slots: {
    header: await container.renderToString(CardHeader),
    footer:  await container.renderToString(CardFooter)
  }
});
```

```
import Card from "../src/components/Card.astro";
import CardHeader from "../src/components/CardHeader.astro";
import CardFooter from "../src/components/CardFooter.astro";


const result = await container.renderToString(Card, {
  slots: {
    header: await container.renderToString(CardHeader),
    footer:  await container.renderToString(CardFooter)
  }
});
```

### props option

```
props
```

Type: Record<string, unknown>

```
Record<string, unknown>
```

An option to pass properties for Astro components.

```
import Card from "../src/components/Card.astro";


const result = await container.renderToString(Card, {
  props: { name: "Hello, world!" }
});
```

```
import Card from "../src/components/Card.astro";


const result = await container.renderToString(Card, {
  props: { name: "Hello, world!" }
});
```

```
---
// For TypeScript support
interface Props {
  name: string;
};


const { name } = Astro.props;
---
<div>
  {name}
</div>
```

```
---
// For TypeScript support
interface Props {
  name: string;
};


const { name } = Astro.props;
---
<div>
  {name}
</div>
```

### request option

```
request
```

Type: Request

```
Request
```

An option to pass a Request with information about the path/URL the component will render.

```
Request
```

Use this option when your component needs to read information like Astro.url or Astro.request.

```
Astro.url
```

```
Astro.request
```

You can also inject possible headers or cookies.

```
import Card from "../src/components/Card.astro";


const result = await container.renderToString(Card, {
  request: new Request("https://example.com/blog", {
    headers: {
      "x-some-secret-header": "test-value"
    }
  })
});
```

```
import Card from "../src/components/Card.astro";


const result = await container.renderToString(Card, {
  request: new Request("https://example.com/blog", {
    headers: {
      "x-some-secret-header": "test-value"
    }
  })
});
```

### params option

```
params
```

Type: Record<string, string | undefined>

```
Record<string, string | undefined>
```

An object to pass information about the path parameter to an Astro component responsible for generating dynamic routes.

Use this option when your component needs a value for Astro.params in order to generate a single route dynamically.

```
Astro.params
```

```
---
const { locale, slug } = Astro.params;
---
<div></div>
```

```
---
const { locale, slug } = Astro.params;
---
<div></div>
```

```
import LocaleSlug from "../src/components/[locale]/[slug].astro";


const result = await container.renderToString(LocaleSlug, {
  params: {
    locale: "en",
    slug: "getting-started"
  }
});
```

```
import LocaleSlug from "../src/components/[locale]/[slug].astro";


const result = await container.renderToString(LocaleSlug, {
  params: {
    locale: "en",
    slug: "getting-started"
  }
});
```

### locals options

```
locals
```

Type: App.Locals

```
App.Locals
```

An option to pass information from Astro.locals for rendering your component.

```
Astro.locals
```

Use this option to when your component needs information stored during the lifecycle of a request in order to render, such as logged in status.

```
---
const { checkAuth } = Astro.locals;
const isAuthenticated = checkAuth();
---
{isAuthenticated ? <span>You're in</span> : <span>You're out</span> }
```

```
---
const { checkAuth } = Astro.locals;
const isAuthenticated = checkAuth();
---
{isAuthenticated ? <span>You're in</span> : <span>You're out</span> }
```

```
import Card from "../src/components/Card.astro";


test("User is in", async () => {
  const result = await container.renderToString(Card, {
    locals: {
      checkAuth() { return true; }
    }
  });


  // assert result contains "You're in"
});




test("User is out", async () => {
  const result = await container.renderToString(Card, {
    locals: {
      checkAuth() { return false; }
    }
  });


  // assert result contains "You're out"
});
```

```
import Card from "../src/components/Card.astro";


test("User is in", async () => {
  const result = await container.renderToString(Card, {
    locals: {
      checkAuth() { return true; }
    }
  });


  // assert result contains "You're in"
});




test("User is out", async () => {
  const result = await container.renderToString(Card, {
    locals: {
      checkAuth() { return false; }
    }
  });


  // assert result contains "You're out"
});
```

### routeType option

```
routeType
```

Type: RouteType

```
RouteType
```

An option available when using renderToResponse() to specify that you are rendering an endpoint:

```
renderToResponse()
```

```
container.renderToString(Endpoint, { routeType: "endpoint" });
```

```
container.renderToString(Endpoint, { routeType: "endpoint" });
```

```
import * as Endpoint from "../src/pages/api/endpoint.js";


const response = await container.renderToResponse(Endpoint, {
  routeType: "endpoint"
});
const json = await response.json();
```

```
import * as Endpoint from "../src/pages/api/endpoint.js";


const response = await container.renderToResponse(Endpoint, {
  routeType: "endpoint"
});
const json = await response.json();
```

To test your endpoint on methods such as POST, PATCH, etc., use the request option to call the correct function:

```
POST
```

```
PATCH
```

```
request
```

```
export function GET() {}


// need to test this
export function POST() {}
```

```
export function GET() {}


// need to test this
export function POST() {}
```

```
import * as Endpoint from "../src/pages/api/endpoint.js";


const response = await container.renderToResponse(Endpoint, {
    routeType: "endpoint",
    request: new Request("https://example.com", {
      method: "POST" // Specify POST method for testing
    })
});
const json = await response.json();
```

```
import * as Endpoint from "../src/pages/api/endpoint.js";


const response = await container.renderToResponse(Endpoint, {
    routeType: "endpoint",
    request: new Request("https://example.com", {
      method: "POST" // Specify POST method for testing
    })
});
const json = await response.json();
```

### partial option

```
partial
```

Type: boolean
Default: true

```
boolean
```

```
true
```

```
astro@4.16.6
```

Whether or not the Container API renders components as if they were page partials. This is usually the behavior you want when rendering components.boolean so you can render components without a full page shell.

```
components.boolean
```

To render a component as a full Astro page, including <!DOCTYPE html>, you can opt-out of this behavior by setting partial to false:

```
<!DOCTYPE html>
```

```
partial
```

```
false
```

```
import Blog from "../src/pages/Blog.astro";


const result = await container.renderToString(Card, {
    partial: false
});
console.log(result) // includes `<!DOCTYPE html>` at the beginning of the HTML
```

```
import Blog from "../src/pages/Blog.astro";


const result = await container.renderToString(Card, {
    partial: false
});
console.log(result) // includes `<!DOCTYPE html>` at the beginning of the HTML
```

## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

