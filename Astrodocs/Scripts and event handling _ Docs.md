- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
Pages
Routing
Endpoints
Middleware
Internationalization (i18n)
Prefetch
View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
Components
Layouts
Styles and CSS
Fonts
Syntax Highlighting
Scripts and event handling
Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
Markdown
Content collections
Images
Data fetching
Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
On-demand rendering
Server islands
Actions
Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
Upgrade Astro
Major upgrade guides
- Upgrade Astro
- Major upgrade guides
- Troubleshooting
- How-to recipes
- Contribute to Astro
- Astro Template Syntax
								
							
							
	



						
						
	
				
						Template expressions reference
						
					
			
				
						Template directives reference
- Template expressions reference
- Template directives reference
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
								
							
							
	



						
						
	
				
						Render context
						
					
			
				
						astro:actions
						
					
			
				
						astro:assets
						
					
			
				
						astro:config
						
					
			
				
						astro:content
						
					
			
				
						astro:env
						
					
			
				
						astro:i18n
						
					
			
				
						astro:middleware
						
					
			
				
						astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
								
							
							
	



						
						
	
				
						Integration API
						
					
			
				
						Adapter API
						
					
			
				
						Content Loader API
						
					
			
				
						Image Service API
						
					
			
				
						Dev Toolbar App API
						
					
			
				
						Container API (experimental)
						
					
			
				
						Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
								
							
							
	



						
						
	
				
						Configuring experimental flags
						
					
			
				
						Content Security Policy
						
					
			
				
						Fonts
						
					
			
				
						Live content collections
						
					
			
				
						Client prerendering
						
					
			
				
						Intellisense for collections
						
					
			
				
						Preserve scripts order
						
					
			
				
						Markdown heading ID compatibility
						
					
			
				
						Private meta environment variables inlining
						
					
			
				
						Chrome DevTools workspace
						
					
			
				
						Prerender conflict error
						
					
			
				
						SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- Client-Side Scripts
- Script processing
				
				
	
				
					Unprocessed scripts
				
				
			
				
					Include JavaScript files on your page
- Unprocessed scripts
- Include JavaScript files on your page
- Common script patterns
				
				
	
				
					Handle onclick and other events
				
				
			
				
					Web components with custom elements
				
				
			
				
					Pass frontmatter variables to scripts
				
				
			
				
					Combining scripts and UI Frameworks
- Handle onclick and other events
- Web components with custom elements
- Pass frontmatter variables to scripts
- Combining scripts and UI Frameworks
## On this page

- Overview
- Client-Side Scripts
- Script processing
Unprocessed scripts
Include JavaScript files on your page
- Unprocessed scripts
- Include JavaScript files on your page
- Common script patterns
Handle onclick and other events
Web components with custom elements
Pass frontmatter variables to scripts
Combining scripts and UI Frameworks
- Handle onclick and other events
- Web components with custom elements
- Pass frontmatter variables to scripts
- Combining scripts and UI Frameworks
## Learn Astro with Coding in Public

150+ video lessons
â€¢
Astro v5 ready

# Scripts and event handling

You can send JavaScript to the browser and add functionality to your Astro components using <script> tags in the component template.

```
<script>
```

Scripts add interactivity to your site, such as handling events or updating content dynamically, without the need for a UI framework like React, Svelte, or Vue. This avoids the overhead of shipping framework JavaScript and doesnâ€™t require you to know any additional framework to create a full-featured website or application.

## Client-Side Scripts

Scripts can be used to add event listeners, send analytics data, play animations, and everything else JavaScript can do on the web.

Astro automatically enhances the HTML standard <script> tag with bundling, TypeScript, and more. See how astro processes scripts for more details.

```
<script>
```

```
<button data-confetti-button>Celebrate!</button>


<script>
  // Import from npm package.
  import confetti from 'canvas-confetti';


  // Find our component DOM on the page.
  const buttons = document.querySelectorAll('[data-confetti-button]');


  // Add event listeners to fire confetti when a button is clicked.
  buttons.forEach((button) => {
    button.addEventListener('click', () => confetti());
  });
</script>
```

```
<button data-confetti-button>Celebrate!</button>


<script>
  // Import from npm package.
  import confetti from 'canvas-confetti';


  // Find our component DOM on the page.
  const buttons = document.querySelectorAll('[data-confetti-button]');


  // Add event listeners to fire confetti when a button is clicked.
  buttons.forEach((button) => {
    button.addEventListener('click', () => confetti());
  });
</script>
```

## Script processing

By default, Astro processes <script> tags that contain no attributes (other than src) in the following ways:

```
<script>
```

```
src
```

- TypeScript support: All scripts are TypeScript by default.
- Import bundling: Import local files or npm modules, which will be bundled together.
- Type Module: Processed scripts become type="module" automatically.
```
type="module"
```

- Deduplication: If a component that contains a <script> is used multiple times on a page, the script will only be included once.
```
<script>
```

- Automatic inlining: If the script is small enough, Astro will inline it directly into the HTML to reduce the number of requests.
```
<script>
  // Processed! Bundled! TypeScript!
  // Importing local scripts and from npm packages works.
</script>
```

```
<script>
  // Processed! Bundled! TypeScript!
  // Importing local scripts and from npm packages works.
</script>
```

### Unprocessed scripts

Astro will not process a <script> tag if it has any attribute other than src.

```
<script>
```

```
src
```

You can add the is:inline directive to intentionally opt out of processing for a script.

```
is:inline
```

```
<script is:inline>
  // Will be rendered into the HTML exactly as written!
  // Not transformed: no TypeScript and no import resolution by Astro.
  // If used inside a component, this code is duplicated for each instance.
</script>
```

```
<script is:inline>
  // Will be rendered into the HTML exactly as written!
  // Not transformed: no TypeScript and no import resolution by Astro.
  // If used inside a component, this code is duplicated for each instance.
</script>
```

### Include JavaScript files on your page

You may want to write your scripts as separate .js/.ts files or need to reference an external script on another server. You can do this by referencing these in a <script> tagâ€™s src attribute.

```
.js
```

```
.ts
```

```
<script>
```

```
src
```

#### Import local scripts

When to use this: when your script lives inside of src/.

```
src/
```

Astro will process these scripts according to the script processing rules.

```
<!-- relative path to script at `src/scripts/local.js` -->
<script src="../scripts/local.js"></script>


<!-- also works for local TypeScript files -->
<script src="./script-with-types.ts"></script>
```

```
<!-- relative path to script at `src/scripts/local.js` -->
<script src="../scripts/local.js"></script>


<!-- also works for local TypeScript files -->
<script src="./script-with-types.ts"></script>
```

#### Load external scripts

When to use this: when your JavaScript file lives inside of public/ or on a CDN.

```
public/
```

To load scripts outside of your projectâ€™s src/ folder, include the is:inline directive. This approach skips the JavaScript processing, bundling, and optimizations that are provided by Astro when you import scripts as described above.

```
src/
```

```
is:inline
```

```
<!-- absolute path to a script at `public/my-script.js` -->
<script is:inline src="/my-script.js"></script>


<!-- full URL to a script on a remote server -->
<script is:inline src="https://my-analytics.com/script.js"></script>
```

```
<!-- absolute path to a script at `public/my-script.js` -->
<script is:inline src="/my-script.js"></script>


<!-- full URL to a script on a remote server -->
<script is:inline src="https://my-analytics.com/script.js"></script>
```

## Common script patterns

### Handle onclick and other events

```
onclick
```

Some UI frameworks use custom syntax for event handling like onClick={...} (React/Preact) or @click="..." (Vue). Astro follows standard HTML more closely and does not use custom syntax for events.

```
onClick={...}
```

```
@click="..."
```

Instead, you can use addEventListener in a <script> tag to handle user interactions.

```
addEventListener
```

```
<script>
```

```
<button class="alert">Click me!</button>


<script>
  // Find all buttons with the `alert` class on the page.
  const buttons = document.querySelectorAll('button.alert');


  // Handle clicks on each button.
  buttons.forEach((button) => {
    button.addEventListener('click', () => {
      alert('Button was clicked!');
    });
  });
</script>
```

```
<button class="alert">Click me!</button>


<script>
  // Find all buttons with the `alert` class on the page.
  const buttons = document.querySelectorAll('button.alert');


  // Handle clicks on each button.
  buttons.forEach((button) => {
    button.addEventListener('click', () => {
      alert('Button was clicked!');
    });
  });
</script>
```

If you have multiple <AlertButton /> components on a page, Astro will not run the script multiple times. Scripts are bundled and only included once per page. Using querySelectorAll ensures that this script attaches the event listener to every button with the alert class found on the page.

```
<AlertButton />
```

```
querySelectorAll
```

```
alert
```

### Web components with custom elements

You can create your own HTML elements with custom behavior using the Web Components standard. Defining a custom element in a .astro component allows you to build interactive components without needing a UI framework library.

```
.astro
```

In this example, we define a new <astro-heart> HTML element that tracks how many times you click the heart button and updates the <span> with the latest count.

```
<astro-heart>
```

```
<span>
```

```
<!-- Wrap the component elements in our custom element â€œastro-heartâ€. -->
<astro-heart>
  <button aria-label="Heart">ðŸ’œ</button> Ã— <span>0</span>
</astro-heart>


<script>
  // Define the behaviour for our new type of HTML element.
  class AstroHeart extends HTMLElement {
    connectedCallback() {
      let count = 0;


      const heartButton = this.querySelector('button');
      const countSpan = this.querySelector('span');


      // Each time the button is clicked, update the count.
      heartButton.addEventListener('click', () => {
        count++;
        countSpan.textContent = count.toString();
      });
    }
  }


  // Tell the browser to use our AstroHeart class for <astro-heart> elements.
  customElements.define('astro-heart', AstroHeart);
</script>
```

```
<!-- Wrap the component elements in our custom element â€œastro-heartâ€. -->
<astro-heart>
  <button aria-label="Heart">ðŸ’œ</button> Ã— <span>0</span>
</astro-heart>


<script>
  // Define the behaviour for our new type of HTML element.
  class AstroHeart extends HTMLElement {
    connectedCallback() {
      let count = 0;


      const heartButton = this.querySelector('button');
      const countSpan = this.querySelector('span');


      // Each time the button is clicked, update the count.
      heartButton.addEventListener('click', () => {
        count++;
        countSpan.textContent = count.toString();
      });
    }
  }


  // Tell the browser to use our AstroHeart class for <astro-heart> elements.
  customElements.define('astro-heart', AstroHeart);
</script>
```

There are two advantages to using a custom element here:

- Instead of searching the whole page using document.querySelector(), you can use this.querySelector(), which only searches within the current custom element instance. This makes it easier to work with only the children of one component instance at a time.
Instead of searching the whole page using document.querySelector(), you can use this.querySelector(), which only searches within the current custom element instance. This makes it easier to work with only the children of one component instance at a time.

```
document.querySelector()
```

```
this.querySelector()
```

- Although a <script> only runs once, the browser will run our custom elementâ€™s connectedCallback() method each time it finds <astro-heart> on the page. This means you can safely write code for one component at a time, even if you intend to use this component multiple times on a page.
Although a <script> only runs once, the browser will run our custom elementâ€™s connectedCallback() method each time it finds <astro-heart> on the page. This means you can safely write code for one component at a time, even if you intend to use this component multiple times on a page.

```
<script>
```

```
connectedCallback()
```

```
<astro-heart>
```

### Pass frontmatter variables to scripts

In Astro components, the code in the frontmatter (between the --- fences) runs on the server and is not available in the browser.

```
---
```

To pass server-side variables to client-side scripts, store them in data-* attributes on HTML elements. Scripts can then access these values using the dataset property.

```
data-*
```

```
dataset
```

In this example component, a message prop is stored in a data-message attribute, so the custom element can read this.dataset.message and get the value of the prop in the browser.

```
message
```

```
data-message
```

```
this.dataset.message
```

```
---
const { message = 'Welcome, world!' } = Astro.props;
---


<!-- Store the message prop as a data attribute. -->
<astro-greet data-message={message}>
  <button>Say hi!</button>
</astro-greet>


<script>
  class AstroGreet extends HTMLElement {
    connectedCallback() {
      // Read the message from the data attribute.
      const message = this.dataset.message;
      const button = this.querySelector('button');
      button.addEventListener('click', () => {
        alert(message);
      });
    }
  }


  customElements.define('astro-greet', AstroGreet);
</script>
```

```
---
const { message = 'Welcome, world!' } = Astro.props;
---


<!-- Store the message prop as a data attribute. -->
<astro-greet data-message={message}>
  <button>Say hi!</button>
</astro-greet>


<script>
  class AstroGreet extends HTMLElement {
    connectedCallback() {
      // Read the message from the data attribute.
      const message = this.dataset.message;
      const button = this.querySelector('button');
      button.addEventListener('click', () => {
        alert(message);
      });
    }
  }


  customElements.define('astro-greet', AstroGreet);
</script>
```

Now we can use our component multiple times and be greeted by a different message for each one.

```
---
import AstroGreet from '../components/AstroGreet.astro';
---


<!-- Use the default message: â€œWelcome, world!â€ -->
<AstroGreet />


<!-- Use custom messages passed as a props. -->
<AstroGreet message="Lovely day to build components!" />
<AstroGreet message="Glad you made it! ðŸ‘‹" />
```

```
---
import AstroGreet from '../components/AstroGreet.astro';
---


<!-- Use the default message: â€œWelcome, world!â€ -->
<AstroGreet />


<!-- Use custom messages passed as a props. -->
<AstroGreet message="Lovely day to build components!" />
<AstroGreet message="Glad you made it! ðŸ‘‹" />
```

Did you know?

This is actually what Astro does behind the scenes when you pass props to a component written using a UI framework like React! For components with a client:* directive, Astro creates an <astro-island> custom element with a props attribute that stores your server-side props in the HTML output.

```
client:*
```

```
<astro-island>
```

```
props
```

### Combining scripts and UI Frameworks

Elements rendered by a UI framework may not be available yet when a <script> tag executes. If your script also needs to handle UI framework components, using a custom element is recommended.

```
<script>
```

## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

