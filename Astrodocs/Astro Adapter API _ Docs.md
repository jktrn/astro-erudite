- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
								
							
							
	



						
						
	
				
						Pages
						
					
			
				
						Routing
						
					
			
				
						Endpoints
						
					
			
				
						Middleware
						
					
			
				
						Internationalization (i18n)
						
					
			
				
						Prefetch
						
					
			
				
						View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
								
							
							
	



						
						
	
				
						Components
						
					
			
				
						Layouts
						
					
			
				
						Styles and CSS
						
					
			
				
						Fonts
						
					
			
				
						Syntax Highlighting
						
					
			
				
						Scripts and event handling
						
					
			
				
						Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
								
							
							
	



						
						
	
				
						Markdown
						
					
			
				
						Content collections
						
					
			
				
						Images
						
					
			
				
						Data fetching
						
					
			
				
						Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
								
							
							
	



						
						
	
				
						On-demand rendering
						
					
			
				
						Server islands
						
					
			
				
						Actions
						
					
			
				
						Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
								
							
							
	



						
						
	
				
						Upgrade Astro
						
					
			
				
						
						
							
								Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- Upgrade Astro
- Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- v5.0
- v4.0
- v3.0
- v2.0
- v1.0
- Troubleshooting
- How-to recipes
								
							
							
	



						
						
	
				
						Recipes overview
						
					
			
				
						Installing a Vite or Rollup plugin
						
					
			
				
						Analyze bundle size
						
					
			
				
						Build a custom image component
						
					
			
				
						Build HTML forms in Astro pages
						
					
			
				
						Build forms with API routes
						
					
			
				
						Use Bun with Astro
						
					
			
				
						Call endpoints from the server
						
					
			
				
						Verify a Captcha
						
					
			
				
						Customize file names in the build output
						
					
			
				
						Build your Astro site with Docker
						
					
			
				
						Dynamically import images
						
					
			
				
						Add icons to external links
						
					
			
				
						Add i18n features
						
					
			
				
						Create a dev toolbar app
						
					
			
				
						Add last modified time
						
					
			
				
						Add reading time
						
					
			
				
						Add an RSS feed
						
					
			
				
						Share state between Astro components
						
					
			
				
						Share state between islands
						
					
			
				
						Using streaming to improve page performance
						
					
			
				
						Style rendered Markdown with Tailwind Typography
- Recipes overview
- Installing a Vite or Rollup plugin
- Analyze bundle size
- Build a custom image component
- Build HTML forms in Astro pages
- Build forms with API routes
- Use Bun with Astro
- Call endpoints from the server
- Verify a Captcha
- Customize file names in the build output
- Build your Astro site with Docker
- Dynamically import images
- Add icons to external links
- Add i18n features
- Create a dev toolbar app
- Add last modified time
- Add reading time
- Add an RSS feed
- Share state between Astro components
- Share state between islands
- Using streaming to improve page performance
- Style rendered Markdown with Tailwind Typography
- Contribute to Astro
- Astro Template Syntax
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
Render context
astro:actions
astro:assets
astro:config
astro:content
astro:env
astro:i18n
astro:middleware
astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
Integration API
Adapter API
Content Loader API
Image Service API
Dev Toolbar App API
Container API (experimental)
Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
Configuring experimental flags
Content Security Policy
Fonts
Live content collections
Client prerendering
Intellisense for collections
Preserve scripts order
Markdown heading ID compatibility
Private meta environment variables inlining
Chrome DevTools workspace
Prerender conflict error
SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- What is an adapter?
- Building an adapter
				
				
	
				
					name
				
				
			
				
					serverEntrypoint
				
				
			
				
					supportedAstroFeatures
				
				
			
				
					adapterFeatures
				
				
			
				
					args
				
				
			
				
					client
				
				
			
				
					exports
				
				
			
				
					previewEntrypoint
- name
- serverEntrypoint
- supportedAstroFeatures
- adapterFeatures
- args
- client
- exports
- previewEntrypoint
- Building a server entrypoint
				
				
	
				
					createExports()
				
				
			
				
					start()
				
				
			
				
					astro/app
				
				
			
				
					astro/app/node
- createExports()
- start()
- astro/app
- astro/app/node
- Astro features
				
				
	
				
					staticOutput
				
				
			
				
					hybridOutput
				
				
			
				
					serverOutput
				
				
			
				
					i18nDomains
				
				
			
				
					envGetSecret
				
				
			
				
					sharpImageService
- staticOutput
- hybridOutput
- serverOutput
- i18nDomains
- envGetSecret
- sharpImageService
- Adapter features
				
				
	
				
					edgeMiddleware
				
				
			
				
					buildOutput
				
				
			
				
					experimentalStaticHeaders
- edgeMiddleware
- buildOutput
- experimentalStaticHeaders
- Adapter types reference
				
				
	
				
					AdapterSupport
				
				
			
				
					AdapterSupportsKind
				
				
			
				
					AdapterSupportWithMessage
- AdapterSupport
- AdapterSupportsKind
- AdapterSupportWithMessage
- Allow installation via astro add
## On this page

- Overview
- What is an adapter?
- Building an adapter
name
serverEntrypoint
supportedAstroFeatures
adapterFeatures
args
client
exports
previewEntrypoint
- name
- serverEntrypoint
- supportedAstroFeatures
- adapterFeatures
- args
- client
- exports
- previewEntrypoint
- Building a server entrypoint
createExports()
start()
astro/app
astro/app/node
- createExports()
- start()
- astro/app
- astro/app/node
- Astro features
staticOutput
hybridOutput
serverOutput
i18nDomains
envGetSecret
sharpImageService
- staticOutput
- hybridOutput
- serverOutput
- i18nDomains
- envGetSecret
- sharpImageService
- Adapter features
edgeMiddleware
buildOutput
experimentalStaticHeaders
- edgeMiddleware
- buildOutput
- experimentalStaticHeaders
- Adapter types reference
AdapterSupport
AdapterSupportsKind
AdapterSupportWithMessage
- AdapterSupport
- AdapterSupportsKind
- AdapterSupportWithMessage
- Allow installation via astro add
## Learn Astro with Coding in Public

150+ video lessons
•
Astro v5 ready

# Astro Adapter API

Astro is designed to make it easy to deploy to any cloud provider for on-demand rendering, also known as server-side rendering (SSR). This ability is provided by adapters, which are integrations. See the on-demand rendering guide to learn how to use an existing adapter.

## What is an adapter?

An adapter is a special kind of integration that provides an entrypoint for server rendering at request time. An adapter has access to the full Integration API and does two things:

- Implements host-specific APIs for handling requests.
- Configures the build according to host conventions.
## Building an adapter

Create an integration and call the setAdapter() function in the astro:config:done hook. This allows you to define a server entrypoint and the features supported by your adapter.

```
setAdapter()
```

```
astro:config:done
```

The following example creates an adapter with a server entrypoint and stable support for Astro static output:

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            staticOutput: 'stable'
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            staticOutput: 'stable'
          }
        });
      },
    },
  };
}
```

The setAdapter() function accepts an object containing the following properties:

```
setAdapter()
```

### name

```
name
```

Type: string

```
string
```

Defines a unique name for your adapter. This will be used for logging.

### serverEntrypoint

```
serverEntrypoint
```

Type: string | URL

```
string | URL
```

Defines the entrypoint for on-demand rendering.

### supportedAstroFeatures

```
supportedAstroFeatures
```

Type: AstroAdapterFeatureMap

```
AstroAdapterFeatureMap
```

```
astro@3.0.0
```

A map of Astro’s built-in features supported by the adapter. This allows Astro to determine which features an adapter supports, so appropriate error messages can be provided.

### adapterFeatures

```
adapterFeatures
```

Type: AstroAdapterFeatures

```
AstroAdapterFeatures
```

```
astro@3.0.0
```

An object that specifies which adapter features that change the build output are supported by the adapter.

### args

```
args
```

Type: any

```
any
```

A JSON-serializable value that will be passed to the adapter’s server entrypoint at runtime. This is useful to pass an object containing build-time configuration (e.g. paths, secrets) to your server runtime code.

The following example defines an args object with a property that identifies where assets generated by Astro are located:

```
args
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          args: {
            assets: config.build.assets
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          args: {
            assets: config.build.assets
          }
        });
      },
    },
  };
}
```

### client

```
client
```

Type: { internalFetchHeaders?: Record<string, string> | () => Record<string, string>; assetQueryParams?: URLSearchParams; }

```
{ internalFetchHeaders?: Record<string, string> | () => Record<string, string>; assetQueryParams?: URLSearchParams; }
```

```
astro@5.15.0
```

A configuration object for Astro’s client-side code.

#### internalFetchHeaders

```
internalFetchHeaders
```

Type: Record<string, string> | () => Record<string, string>

```
Record<string, string> | () => Record<string, string>
```

Defines the headers to inject into Astro’s internal fetch calls (e.g. Actions, View Transitions, Server Islands, Prefetch). This can be an object of headers or a function that returns headers.

The following example retrieves a DEPLOY_ID from the environment variables and, if provided, returns an object with the header name as key and the deploy id as value:

```
DEPLOY_ID
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          client: {
            internalFetchHeaders: () => {
              const deployId = process.env.DEPLOY_ID;
              return deployId ? { 'Your-Header-ID': deployId } : {};
            },
          },
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          client: {
            internalFetchHeaders: () => {
              const deployId = process.env.DEPLOY_ID;
              return deployId ? { 'Your-Header-ID': deployId } : {};
            },
          },
        });
      },
    },
  };
}
```

#### assetQueryParams

```
assetQueryParams
```

Type: URLSearchParams

```
URLSearchParams
```

Defines the query parameters to append to all asset URLs (e.g. images, stylesheets, scripts). This is useful for adapters that need to track deployment versions or other metadata.

The following example retrieves a DEPLOY_ID from the environment variables and, if provided, returns an object with a custom search parameter name as key and the deploy id as value:

```
DEPLOY_ID
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          client: {
            assetQueryParams: process.env.DEPLOY_ID
              ? new URLSearchParams({ yourParam: process.env.DEPLOY_ID })
              : undefined,
          },
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          client: {
            assetQueryParams: process.env.DEPLOY_ID
              ? new URLSearchParams({ yourParam: process.env.DEPLOY_ID })
              : undefined,
          },
        });
      },
    },
  };
}
```

### exports

```
exports
```

Type: string[]

```
string[]
```

Defines an array of named exports to use in conjunction with the createExports() function of your server entrypoint.

```
createExports()
```

The following example assumes that createExports() provides an export named handler:

```
createExports()
```

```
handler
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          exports: ['handler']
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          exports: ['handler']
        });
      },
    },
  };
}
```

### previewEntrypoint

```
previewEntrypoint
```

Type: string | URL

```
string | URL
```

```
astro@1.5.0
```

Defines the path or ID of a module in the adapter’s package that is responsible for starting up the built server when astro preview is run.

```
astro preview
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          previewEntrypoint: '@example/my-adapter/preview.js',
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          previewEntrypoint: '@example/my-adapter/preview.js',
        });
      },
    },
  };
}
```

## Building a server entrypoint

You will need to create a file that executes during server-side requests to enable on-demand rendering with your particular host. Astro’s adapter API attempts to work with any type of host and gives a flexible way to conform to the host APIs.

### createExports()

```
createExports()
```

Type: (manifest: SSRManifest, options: any) => Record<string, any>

```
(manifest: SSRManifest, options: any) => Record<string, any>
```

An exported function that takes an SSR manifest as its first argument and an object containing your adapter args as its second argument. This should provide the exports required by your host.

```
args
```

For example, some serverless hosts expect you to export an handler() function. With the adapter API, you achieve this by implementing createExports() in your server entrypoint:

```
handler()
```

```
createExports()
```

```
import { App } from 'astro/app';


export function createExports(manifest) {
  const app = new App(manifest);


  const handler = (event, context) => {
    // ...
  };


  return { handler };
}
```

```
import { App } from 'astro/app';


export function createExports(manifest) {
  const app = new App(manifest);


  const handler = (event, context) => {
    // ...
  };


  return { handler };
}
```

And then in your integration, where you call setAdapter(), provide this name in exports:

```
setAdapter()
```

```
exports
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          exports: ['handler'],
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          exports: ['handler'],
        });
      },
    },
  };
}
```

You can access the args defined by your adapter through the second argument of createExports(). This can be useful when you need to access build-time configuration in your server entrypoint. For example, your server might need to identify where assets generated by Astro are located:

```
args
```

```
createExports()
```

```
import { App } from 'astro/app';


export function createExports(manifest, args) {
  const assetsPath = args.assets;


  const handler = (event, context) => {
    // ...
  };


  return { handler };
}
```

```
import { App } from 'astro/app';


export function createExports(manifest, args) {
  const assetsPath = args.assets;


  const handler = (event, context) => {
    // ...
  };


  return { handler };
}
```

### start()

```
start()
```

Type: (manifest: SSRManifest, options: any) => Record<string, any>

```
(manifest: SSRManifest, options: any) => Record<string, any>
```

An exported function that takes an SSR manifest as its first argument and an object containing your adapter args as its second argument.

```
args
```

Some hosts expect you to start the server yourselves, for example, by listening to a port. For these types of hosts, the adapter API allows you to export a start() function, which will be called when the bundle script is run.

```
start()
```

```
import { App } from 'astro/app';


export function start(manifest) {
  const app = new App(manifest);


  addEventListener('fetch', event => {
    // ...
  });
}
```

```
import { App } from 'astro/app';


export function start(manifest) {
  const app = new App(manifest);


  addEventListener('fetch', event => {
    // ...
  });
}
```

### astro/app

```
astro/app
```

This module is used for rendering pages that have been prebuilt through astro build. Astro uses the standard Request and Response objects. Hosts that have a different API for request/response should convert to these types in their adapter.

```
astro build
```

```
Request
```

```
Response
```

The App constructor accepts a required SSR manifest argument, and optionally an argument to enable or disable streaming, defaulting to true.

```
App
```

```
true
```

```
import { App } from 'astro/app';
import http from 'http';


export function start(manifest) {
  const app = new App(manifest);


  addEventListener('fetch', event => {
    event.respondWith(
      app.render(event.request)
    );
  });
}
```

```
import { App } from 'astro/app';
import http from 'http';


export function start(manifest) {
  const app = new App(manifest);


  addEventListener('fetch', event => {
    event.respondWith(
      app.render(event.request)
    );
  });
}
```

The following methods are provided:

#### app.render()

```
app.render()
```

Type: (request: Request, options?: RenderOptions) => Promise<Response>

```
(request: Request, options?: RenderOptions) => Promise<Response>
```

A method that accepts a required request argument and an optional RenderOptions object. This calls the Astro page that matches the request, renders it, and returns a promise to a Response object. This also works for API routes that do not render pages.

```
request
```

```
RenderOptions
```

```
Response
```

```
const response = await app.render(request);
```

```
const response = await app.render(request);
```

##### RenderOptions

```
RenderOptions
```

Type: {addCookieHeader?: boolean; clientAddress?: string; locals?: object; prerenderedErrorPageFetch?: (url: ErrorPagePath) => Promise<Response>; routeData?: RouteData;}

```
{addCookieHeader?: boolean; clientAddress?: string; locals?: object; prerenderedErrorPageFetch?: (url: ErrorPagePath) => Promise<Response>; routeData?: RouteData;}
```

An object that controls the rendering and contains the following properties:

###### addCookieHeader

```
addCookieHeader
```

Type: boolean
Default: false

```
boolean
```

```
false
```

Whether or not to automatically add all cookies written by Astro.cookie.set() to the response headers.

```
Astro.cookie.set()
```

When set to true, they will be added to the Set-Cookie header of the response as comma-separated key-value pairs. You can use the standard response.headers.getSetCookie() API to read them individually. When set to false(default), the cookies will only be available from App.getSetCookieFromResponse(response).

```
true
```

```
Set-Cookie
```

```
response.headers.getSetCookie()
```

```
false
```

```
App.getSetCookieFromResponse(response)
```

```
const response = await app.render(request, { addCookieHeader: true });
```

```
const response = await app.render(request, { addCookieHeader: true });
```

###### clientAddress

```
clientAddress
```

Type: string
Default: request[Symbol.for("astro.clientAddress")]

```
string
```

```
request[Symbol.for("astro.clientAddress")]
```

The client IP address that will be made available as Astro.clientAddress in pages, and as ctx.clientAddress in API routes and middleware.

```
Astro.clientAddress
```

```
ctx.clientAddress
```

The example below reads the x-forwarded-for header and passes it as clientAddress. This value becomes available to the user as Astro.clientAddress.

```
x-forwarded-for
```

```
clientAddress
```

```
Astro.clientAddress
```

```
const clientAddress = request.headers.get("x-forwarded-for");
const response = await app.render(request, { clientAddress });
```

```
const clientAddress = request.headers.get("x-forwarded-for");
const response = await app.render(request, { clientAddress });
```

###### locals

```
locals
```

Type: object

```
object
```

The context.locals object used to store and access information during the lifecycle of a request.

```
context.locals
```

The example below reads a header named x-private-header, attempts to parse it as an object and pass it to locals, which can then be passed to any middleware function.

```
x-private-header
```

```
locals
```

```
const privateHeader = request.headers.get("x-private-header");
let locals = {};
try {
  if (privateHeader) {
    locals = JSON.parse(privateHeader);
  }
} finally {
  const response = await app.render(request, { locals });
}
```

```
const privateHeader = request.headers.get("x-private-header");
let locals = {};
try {
  if (privateHeader) {
    locals = JSON.parse(privateHeader);
  }
} finally {
  const response = await app.render(request, { locals });
}
```

###### prerenderedErrorPageFetch()

```
prerenderedErrorPageFetch()
```

Type: (url: ErrorPagePath) => Promise<Response>
Default: fetch

```
(url: ErrorPagePath) => Promise<Response>
```

```
fetch
```

```
astro@5.6.0
```

A function that allows you to provide custom implementations for fetching prerendered error pages.

This is used to override the default fetch() behavior, for example, when fetch() is unavailable or when you cannot call the server from itself.

```
fetch()
```

```
fetch()
```

The following example reads 500.html and 404.html from disk instead of performing an HTTP call:

```
500.html
```

```
404.html
```

```
return app.render(request, {
  prerenderedErrorPageFetch: async (url: string): Promise<Response> => {
    if (url.includes("/500")) {
      const content = await fs.promises.readFile("500.html", "utf-8");
      return new Response(content, {
        status: 500,
        headers: { "Content-Type": "text/html" },
      });
    }


    const content = await fs.promises.readFile("404.html", "utf-8");
    return new Response(content, {
      status: 404,
      headers: { "Content-Type": "text/html" },
    });
  }
});
```

```
return app.render(request, {
  prerenderedErrorPageFetch: async (url: string): Promise<Response> => {
    if (url.includes("/500")) {
      const content = await fs.promises.readFile("500.html", "utf-8");
      return new Response(content, {
        status: 500,
        headers: { "Content-Type": "text/html" },
      });
    }


    const content = await fs.promises.readFile("404.html", "utf-8");
    return new Response(content, {
      status: 404,
      headers: { "Content-Type": "text/html" },
    });
  }
});
```

If not provided, Astro will fallback to its default behavior for fetching error pages.

###### routeData

```
routeData
```

Type: RouteData
Default: app.match(request)

```
RouteData
```

```
app.match(request)
```

Provides a value for integrationRouteData if you already know the route to render. Doing so will bypass the internal call to app.match() to determine the route to render.

```
integrationRouteData
```

```
app.match()
```

```
const routeData = app.match(request);
if (routeData) {
  return app.render(request, { routeData });
} else {
  /* adapter-specific 404 response */
  return new Response(..., { status: 404 });
}
```

```
const routeData = app.match(request);
if (routeData) {
  return app.render(request, { routeData });
} else {
  /* adapter-specific 404 response */
  return new Response(..., { status: 404 });
}
```

#### app.match()

```
app.match()
```

Type: (request: Request, allowPrerenderedRoutes = false) => RouteData | undefined

```
(request: Request, allowPrerenderedRoutes = false) => RouteData | undefined
```

Determines if a request is matched by the Astro app’s routing rules.

```
if(app.match(request)) {
  const response = await app.render(request);
}
```

```
if(app.match(request)) {
  const response = await app.render(request);
}
```

You can usually call app.render(request) without using .match because Astro handles 404s if you provide a 404.astro file. Use app.match(request) if you want to handle 404s in a different way.

```
app.render(request)
```

```
.match
```

```
404.astro
```

```
app.match(request)
```

By default, prerendered routes aren’t returned, even if they are matched. You can change this behavior by using true as the second argument.

```
true
```

#### app.getAdapterLogger()

```
app.getAdapterLogger()
```

Type: () => AstroIntegrationLogger

```
() => AstroIntegrationLogger
```

```
astro@v3.0.0
```

Returns an instance of the Astro logger available to the adapter’s runtime environment.

```
const logger = app.getAdapterLogger();
try {
  /* Some logic that can throw */
} catch {
  logger.error("Your custom error message using Astro logger.");
}
```

```
const logger = app.getAdapterLogger();
try {
  /* Some logic that can throw */
} catch {
  logger.error("Your custom error message using Astro logger.");
}
```

#### app.getAllowedDomains()

```
app.getAllowedDomains()
```

Type: () => Partial<RemotePattern>[] | undefined

```
() => Partial<RemotePattern>[] | undefined
```

```
astro@5.14.2
```

Returns a list of permitted host patterns for incoming requests when using on-demand rendering as defined in the user configuration.

#### app.removeBase()

```
app.removeBase()
```

Type: (pathname: string) => string

```
(pathname: string) => string
```

```
astro@1.6.4
```

Removes the base from the given path. This is useful when you need to look up assets from the filesystem.

#### app.setCookieHeaders()

```
app.setCookieHeaders()
```

Type: (response: Response) => Generator<string, string[], any>

```
(response: Response) => Generator<string, string[], any>
```

```
astro@1.4.0
```

Returns a generator that yields individual cookie header values from a Response object. This is used to properly handle multiple cookies that may have been set during request processing.

```
Response
```

The following example appends a Set-Cookie header for each header obtained from a response:

```
Set-Cookie
```

```
for (const setCookieHeader of app.setCookieHeaders(response)) {
  response.headers.append('Set-Cookie', setCookieHeader);
}
```

```
for (const setCookieHeader of app.setCookieHeaders(response)) {
  response.headers.append('Set-Cookie', setCookieHeader);
}
```

#### App.getSetCookieFromResponse()

```
App.getSetCookieFromResponse()
```

Type: (response: Response) => Generator<string, string[]>

```
(response: Response) => Generator<string, string[]>
```

```
astro@4.2.0
```

Returns a generator that yields individual cookie header values from a Response object. This works in the same way as app.setCookieHeaders(), but can be used at any time as it is a static method.

```
Response
```

```
app.setCookieHeaders()
```

The following example appends a Set-Cookie header for each header obtained from a response:

```
Set-Cookie
```

```
for (const cookie of App.getSetCookieFromResponse(response)) {
  response.headers.append('Set-Cookie', cookie);
}
```

```
for (const cookie of App.getSetCookieFromResponse(response)) {
  response.headers.append('Set-Cookie', cookie);
}
```

#### App.validateForwardedHost()

```
App.validateForwardedHost()
```

Type: (forwardedHost: string, allowedDomains?: Partial<RemotePattern>[], protocol?: string = 'https') => boolean

```
(forwardedHost: string, allowedDomains?: Partial<RemotePattern>[], protocol?: string = 'https') => boolean
```

```
astro@5.14.2
```

Checks whether a forwardedHost matches any of the given allowedDomains. This static method accepts a third argument that allows you to override the host protocol, defaulting to https.

```
forwardedHost
```

```
allowedDomains
```

```
https
```

The following example retrieves the forwardedHost from the headers and checks if the host matches an allowed domain:

```
forwardedHost
```

```
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const forwardedHost = event.request.headers.get('X-Forwarded-Host');
    if (App.validateForwardedHost(forwardedHost, manifest.allowedDomains)) {
      /* do something */
    }
  });
}
```

```
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const forwardedHost = event.request.headers.get('X-Forwarded-Host');
    if (App.validateForwardedHost(forwardedHost, manifest.allowedDomains)) {
      /* do something */
    }
  });
}
```

#### App.sanitizeHost()

```
App.sanitizeHost()
```

Type: (hostname: string | undefined) => string | undefined

```
(hostname: string | undefined) => string | undefined
```

```
astro@5.15.5
```

Validates a hostname by rejecting any name containing path separators. When a hostname is invalid, this static method will return undefined.

```
undefined
```

The following example retrieves the forwardedHost from the headers and sanitizes it:

```
forwardedHost
```

```
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const forwardedHost = event.request.headers.get('X-Forwarded-Host');
    const sanitized = App.sanitizeHost(forwardedHost);
  });
}
```

```
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const forwardedHost = event.request.headers.get('X-Forwarded-Host');
    const sanitized = App.sanitizeHost(forwardedHost);
  });
}
```

#### App.validateForwardedHeaders()

```
App.validateForwardedHeaders()
```

Type: (forwardedProtocol?: string, forwardedHost?: string, forwardedPort?: string, allowedDomains?: Partial<RemotePattern>[]) => { protocol?: string; host?: string; port?: string }

```
(forwardedProtocol?: string, forwardedHost?: string, forwardedPort?: string, allowedDomains?: Partial<RemotePattern>[]) => { protocol?: string; host?: string; port?: string }
```

```
astro@5.15.5
```

Validates the forwarded protocol, host, and port against the allowedDomains. This static method returns validated values or undefined for rejected headers.

```
allowedDomains
```

```
undefined
```

The following example validates the forwarded headers against the authorized domains defined in the received manifest:

```
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const validated = App.validateForwardedHeaders(
      request.headers.get('X-Forwarded-Proto') ?? undefined,
      request.headers.get('X-Forwarded-Host') ?? undefined,
      request.headers.get('X-Forwarded-Port') ?? undefined,
      manifest.allowedDomains,
    );
  });
}
```

```
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const validated = App.validateForwardedHeaders(
      request.headers.get('X-Forwarded-Proto') ?? undefined,
      request.headers.get('X-Forwarded-Host') ?? undefined,
      request.headers.get('X-Forwarded-Port') ?? undefined,
      manifest.allowedDomains,
    );
  });
}
```

### astro/app/node

```
astro/app/node
```

Just like astro/app, this module is used for rendering pages that have been prebuilt through astro build. This allows you to create a NodeApp providing all the methods available from App and additional methods useful for Node environments.

```
astro/app
```

```
astro build
```

```
NodeApp
```

```
App
```

The NodeApp constructor accepts a required SSR manifest argument, and optionally an argument to enable or disable streaming, defaulting to true.

```
NodeApp
```

```
true
```

```
import { NodeApp } from 'astro/app/node';
import http from 'http';


export function start(manifest) {
  const nodeApp = new NodeApp(manifest);


  addEventListener('fetch', event => {
    event.respondWith(
      nodeApp.render(event.request)
    );
  });
}
```

```
import { NodeApp } from 'astro/app/node';
import http from 'http';


export function start(manifest) {
  const nodeApp = new NodeApp(manifest);


  addEventListener('fetch', event => {
    event.respondWith(
      nodeApp.render(event.request)
    );
  });
}
```

The following additional methods are provided:

#### nodeApp.render()

```
nodeApp.render()
```

Type: (request: NodeRequest | Request, options?: RenderOptions) => Promise<Response>

```
(request: NodeRequest | Request, options?: RenderOptions) => Promise<Response>
```

```
astro@4.0.0
```

Extends app.render() to also accept Node.js IncomingMessage objects in addition to standard Request objects as the first argument. The second argument is an optional object allowing you to control the rendering.

```
app.render()
```

```
IncomingMessage
```

```
Request
```

```
const response = await nodeApp.render(request);
```

```
const response = await nodeApp.render(request);
```

#### nodeApp.match()

```
nodeApp.match()
```

Type: (req: NodeRequest | Request, allowPrerenderedRoutes?: boolean) => RouteData | undefined

```
(req: NodeRequest | Request, allowPrerenderedRoutes?: boolean) => RouteData | undefined
```

Extends app.match() to also accept Node.js IncomingMessage objects in addition to standard Request objects.

```
app.match()
```

```
IncomingMessage
```

```
Request
```

```
if(nodeApp.match(request)) {
  const response = await nodeApp.render(request);
}
```

```
if(nodeApp.match(request)) {
  const response = await nodeApp.render(request);
}
```

#### nodeApp.headersMap

```
nodeApp.headersMap
```

Type: NodeAppHeadersJson | undefined
Default: undefined

```
NodeAppHeadersJson | undefined
```

```
undefined
```

```
astro@5.11.0
```

An array containing the headers configuration. Each entry maps a pathname to a list of headers that should be applied for that route. This is useful for applying headers such as CSP directives to prerendered routes.

#### nodeApp.setHeadersMap()

```
nodeApp.setHeadersMap()
```

Type: (headers: NodeAppHeadersJson) => void

```
(headers: NodeAppHeadersJson) => void
```

```
astro@5.11.0
```

Loads headers configuration into the NodeApp instance.

```
NodeApp
```

```
nodeApp.setHeadersMap([
  {
    pathname: "/blog",
    headers: [
      { key: "Content-Security-Policy", value: "default-src 'self'" },
    ]
  }
]);
```

```
nodeApp.setHeadersMap([
  {
    pathname: "/blog",
    headers: [
      { key: "Content-Security-Policy", value: "default-src 'self'" },
    ]
  }
]);
```

#### NodeApp.createRequest()

```
NodeApp.createRequest()
```

Type: (req: NodeRequest, options?: { skipBody?: boolean; allowedDomains?: Partial<RemotePattern>[]; }) => Request

```
(req: NodeRequest, options?: { skipBody?: boolean; allowedDomains?: Partial<RemotePattern>[]; }) => Request
```

```
astro@4.2.0
```

Converts a NodeJS IncomingMessage into a standard Request object. This static method accepts an optional object as the second argument, allowing you to define if the body should be ignored, defaulting to false, and the allowedDomains.

```
IncomingMessage
```

```
Request
```

```
false
```

```
allowedDomains
```

The following example creates a Request and passes it to app.render():

```
Request
```

```
app.render()
```

```
import { NodeApp } from 'astro/app/node';
import { createServer } from 'node:http';


const server = createServer(async (req, res) => {
  const request = NodeApp.createRequest(req);
  const response = await app.render(request);
})
```

```
import { NodeApp } from 'astro/app/node';
import { createServer } from 'node:http';


const server = createServer(async (req, res) => {
  const request = NodeApp.createRequest(req);
  const response = await app.render(request);
})
```

#### NodeApp.writeResponse()

```
NodeApp.writeResponse()
```

Type: (source: Response, destination: ServerResponse) => Promise<ServerResponse<IncomingMessage> | undefined>

```
(source: Response, destination: ServerResponse) => Promise<ServerResponse<IncomingMessage> | undefined>
```

```
astro@4.2.0
```

Streams a web-standard Response into a NodeJS server response. This static method takes a Response object and the initial ServerResponse before returning a promise of a ServerResponse object.

```
Response
```

```
Response
```

```
ServerResponse
```

```
ServerResponse
```

The following example creates a Request, passes it to app.render(), and writes the response:

```
Request
```

```
app.render()
```

```
import { NodeApp } from 'astro/app/node';
import { createServer } from 'node:http';


const server = createServer(async (req, res) => {
  const request = NodeApp.createRequest(req);
  const response = await app.render(request);
  await NodeApp.writeResponse(response, res);
})
```

```
import { NodeApp } from 'astro/app/node';
import { createServer } from 'node:http';


const server = createServer(async (req, res) => {
  const request = NodeApp.createRequest(req);
  const response = await app.render(request);
  await NodeApp.writeResponse(response, res);
})
```

## Astro features

Astro features are a way for an adapter to tell Astro whether they are able to support a feature, and also the adapter’s level of support.

When using these properties, Astro will:

- run specific validation;
- emit contextual information to the logs;
These operations are run based on the features supported or not supported, their level of support, the desired amount of logging, and the user’s own configuration.

The following configuration tells Astro that this adapter has experimental support for the Sharp-powered built-in image service:

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: 'experimental'
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: 'experimental'
          }
        });
      },
    },
  };
}
```

If the Sharp image service is used, Astro will log a warning and error to the terminal based on your adapter’s support:

```
[@example/my-adapter] The feature is experimental and subject to issues or changes.


[@example/my-adapter] The currently selected adapter `@example/my-adapter` is not compatible with the service "Sharp". Your project will NOT be able to build.
```

```
[@example/my-adapter] The feature is experimental and subject to issues or changes.


[@example/my-adapter] The currently selected adapter `@example/my-adapter` is not compatible with the service "Sharp". Your project will NOT be able to build.
```

A message can additionally be provided to give more context to the user:

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'This adapter has limited support for Sharp. Certain features may not work as expected.'
            }
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'This adapter has limited support for Sharp. Certain features may not work as expected.'
            }
          }
        });
      },
    },
  };
}
```

This object contains the following configurable features:

### staticOutput

```
staticOutput
```

Type: AdapterSupport

```
AdapterSupport
```

Defines whether the adapter is able to serve static pages.

### hybridOutput

```
hybridOutput
```

Type: AdapterSupport

```
AdapterSupport
```

Defines whether the adapter is able to serve sites that include a mix of static and on-demand rendered pages.

### serverOutput

```
serverOutput
```

Type: AdapterSupport

```
AdapterSupport
```

Defines whether the adapter is able to serve on-demand rendered pages.

### i18nDomains

```
i18nDomains
```

Type: AdapterSupport

```
AdapterSupport
```

```
astro@4.3.0
```

Defines whether the adapter is able to support i18n domains.

### envGetSecret

```
envGetSecret
```

Type: AdapterSupport

```
AdapterSupport
```

```
astro@4.10.0
```

Defines whether the adapter is able to support getSecret() exported from astro:env/server. When enabled, this feature allows your adapter to retrieve secrets configured by users in env.schema.

```
getSecret()
```

```
astro:env/server
```

```
env.schema
```

The following example enables the feature by passing a valid AdapterSupportsKind value to the adapter:

```
AdapterSupportsKind
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            envGetSecret: 'stable'
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            envGetSecret: 'stable'
          }
        });
      },
    },
  };
}
```

The astro/env/setup module allows you to provide an implementation for getSecret(). In your server entrypoint, call setGetEnv() as soon as possible:

```
astro/env/setup
```

```
getSecret()
```

```
setGetEnv()
```

```
import { App } from 'astro/app';
import { setGetEnv } from "astro/env/setup"


setGetEnv((key) => process.env[key])


export function createExports(manifest) {
  const app = new App(manifest);


  const handler = (event, context) => {
    // ...
  };


  return { handler };
}
```

```
import { App } from 'astro/app';
import { setGetEnv } from "astro/env/setup"


setGetEnv((key) => process.env[key])


export function createExports(manifest) {
  const app = new App(manifest);


  const handler = (event, context) => {
    // ...
  };


  return { handler };
}
```

If the adapter supports secrets, be sure to call setGetEnv() before getSecret() when environment variables are tied to the request:

```
setGetEnv()
```

```
getSecret()
```

```
import type { SSRManifest } from 'astro';
import { App } from 'astro/app';
import { setGetEnv } from 'astro/env/setup';
import { createGetEnv } from '../utils/env.js';


type Env = {
  [key: string]: unknown;
};


export function createExports(manifest: SSRManifest) {
  const app = new App(manifest);


  const fetch = async (request: Request, env: Env) => {
    setGetEnv(createGetEnv(env));


    const response = await app.render(request);


    return response;
  };


  return { default: { fetch } };
}
```

```
import type { SSRManifest } from 'astro';
import { App } from 'astro/app';
import { setGetEnv } from 'astro/env/setup';
import { createGetEnv } from '../utils/env.js';


type Env = {
  [key: string]: unknown;
};


export function createExports(manifest: SSRManifest) {
  const app = new App(manifest);


  const fetch = async (request: Request, env: Env) => {
    setGetEnv(createGetEnv(env));


    const response = await app.render(request);


    return response;
  };


  return { default: { fetch } };
}
```

### sharpImageService

```
sharpImageService
```

Type: AdapterSupport

```
AdapterSupport
```

```
astro@5.0.0
```

Defines whether the adapter supports image transformation using the built-in Sharp image service.

## Adapter features

A set of features that changes the output of the emitted files. When an adapter opts in to these features, they will get additional information inside specific hooks and must implement the proper logic to handle the different output.

### edgeMiddleware

```
edgeMiddleware
```

Type: boolean

```
boolean
```

Defines whether any on-demand rendering middleware code will be bundled when built.

When enabled, this prevents middleware code from being bundled and imported by all pages during the build:

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            edgeMiddleware: true
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            edgeMiddleware: true
          }
        });
      },
    },
  };
}
```

Then, consume the hook astro:build:ssr, which will give you a middlewareEntryPoint, an URL to the physical file on the file system.

```
astro:build:ssr
```

```
middlewareEntryPoint
```

```
URL
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            edgeMiddleware: true
          }
        });
      },


      'astro:build:ssr': ({ middlewareEntryPoint }) => {
        // remember to check if this property exits, it will be `undefined` if the adapter doesn't opt in to the feature
        if (middlewareEntryPoint) {
          createEdgeMiddleware(middlewareEntryPoint)
        }
      }
    },
  };
}


function createEdgeMiddleware(middlewareEntryPoint) {
  // emit a new physical file using your bundler
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            edgeMiddleware: true
          }
        });
      },


      'astro:build:ssr': ({ middlewareEntryPoint }) => {
        // remember to check if this property exits, it will be `undefined` if the adapter doesn't opt in to the feature
        if (middlewareEntryPoint) {
          createEdgeMiddleware(middlewareEntryPoint)
        }
      }
    },
  };
}


function createEdgeMiddleware(middlewareEntryPoint) {
  // emit a new physical file using your bundler
}
```

### buildOutput

```
buildOutput
```

Type: "static" | "server"
Default: "server"

```
"static" | "server"
```

```
"server"
```

```
astro@5.0.0
```

Allows you to force a specific output shape for the build. This can be useful for adapters that only work with a specific output type. For example, your adapter might expect a static website, but uses an adapter to create host-specific files. Defaults to server if not specified.

```
server
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            buildOutput: 'static'
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            buildOutput: 'static'
          }
        });
      },
    },
  };
}
```

### experimentalStaticHeaders

```
experimentalStaticHeaders
```

Type: boolean

```
boolean
```

```
astro@5.9.3
```

Whether or not the adapter provides experimental support for setting response headers for static pages. When this feature is enabled, Astro will return a map of the Headers emitted by the static pages. This map experimentalRouteToHeaders is available in the astro:build:generated hook for generating files such as a _headers that allows you to make changes to the default HTTP header.

```
Headers
```

```
experimentalRouteToHeaders
```

```
astro:build:generated
```

```
_headers
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            experimentalStaticHeaders: true,
          },
        });
      },
      'astro:build:generated': ({ experimentalRouteToHeaders }) => {
        // use `experimentalRouteToHeaders` to generate a configuration file
        // for your virtual host of choice
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            experimentalStaticHeaders: true,
          },
        });
      },
      'astro:build:generated': ({ experimentalRouteToHeaders }) => {
        // use `experimentalRouteToHeaders` to generate a configuration file
        // for your virtual host of choice
      },
    },
  };
}
```

The value of the headers might change based on the features enabled/used by the application. For example, if CSP is enabled, the <meta http-equiv="content-security-policy"> element is not added to the static page. Instead, its content is available in the experimentalRouteToHeaders map.

```
<meta http-equiv="content-security-policy">
```

```
content
```

```
experimentalRouteToHeaders
```

## Adapter types reference

### AdapterSupport

```
AdapterSupport
```

Type: AdapterSupportsKind | AdapterSupportWithMessage

```
AdapterSupportsKind | AdapterSupportWithMessage
```

```
astro@5.0.0
```

A union of valid formats to describe the support level for a feature.

### AdapterSupportsKind

```
AdapterSupportsKind
```

Type: "deprecated" | "experimental" | "limited" | "stable" | "unsupported"

```
"deprecated" | "experimental" | "limited" | "stable" | "unsupported"
```

Defines the level of support for a feature by your adapter:

- Use "deprecated" when your adapter deprecates support for a feature before removing it completely in a future version.
```
"deprecated"
```

- Use "experimental" when your adapter adds support for a feature, but issues or breaking changes are expected.
```
"experimental"
```

- Use "limited" when your adapter only supports a subset of the full feature.
```
"limited"
```

- Use "stable" when the feature is fully supported by your adapter.
```
"stable"
```

- Use "unsupported" to warn users that they may encounter build issues in their project, as this feature is not supported by your adapter.
```
"unsupported"
```

### AdapterSupportWithMessage

```
AdapterSupportWithMessage
```

Added in: astro@5.0.0

```
astro@5.0.0
```

An object that allows you to define a support level for a feature and a message to be logged in the user console. This object contains the following properties:

#### support

```
support
```

Type: Exclude<AdapterSupportsKind, “stable”>

```
Exclude<AdapterSupportsKind, “stable”>
```

Defines the level of support for a feature by your adapter.

#### message

```
message
```

Type: string

```
string
```

Defines a custom message to log regarding the support of a feature by your adapter.

#### suppress

```
suppress
```

Type: "default" | "all"

```
"default" | "all"
```

```
astro@5.9.0
```

An option to prevent showing some or all logged messages about an adapter’s support for a feature.

If Astro’s default log message is redundant, or confusing to the user in combination with your custom message, you can use suppress: "default" to suppress the default message and only log your message:

```
message
```

```
suppress: "default"
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'The adapter has limited support for Sharp. It will be used for images during build time, but will not work at runtime.',
              suppress: 'default' // custom message is more detailed than the default
            }
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'The adapter has limited support for Sharp. It will be used for images during build time, but will not work at runtime.',
              suppress: 'default' // custom message is more detailed than the default
            }
          }
        });
      },
    },
  };
}
```

You can also use suppress: "all" to suppress all messages about support for the feature. This is useful when these messages are unhelpful to users in a specific context, such as when they have a configuration setting that means they are not using that feature. For example, you can choose to prevent logging any messages about Sharp support from your adapter:

```
suppress: "all"
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'This adapter has limited support for Sharp. Certain features may not work as expected.',
              suppress: 'all'
            }
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'This adapter has limited support for Sharp. Certain features may not work as expected.',
              suppress: 'all'
            }
          }
        });
      },
    },
  };
}
```

## Allow installation via astro add

```
astro add
```

The astro add command allows users to easily add integrations and adapters to their project. To allow your adapter to be installed with this command, add astro-adapter to the keywords field in your package.json:

```
astro add
```

```
astro-adapter
```

```
keywords
```

```
package.json
```

```
{
  "name": "example",
  "keywords": ["astro-adapter"],
}
```

```
{
  "name": "example",
  "keywords": ["astro-adapter"],
}
```

Once you publish your adapter to npm, running astro add example will install your package with any peer dependencies specified in your package.json and instruct users to update their project config manually.

```
astro add example
```

```
package.json
```

## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

