- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
Pages
Routing
Endpoints
Middleware
Internationalization (i18n)
Prefetch
View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
Components
Layouts
Styles and CSS
Fonts
Syntax Highlighting
Scripts and event handling
Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
Markdown
Content collections
Images
Data fetching
Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
On-demand rendering
Server islands
Actions
Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
Upgrade Astro
Major upgrade guides
- Upgrade Astro
- Major upgrade guides
- Troubleshooting
- How-to recipes
- Contribute to Astro
- Astro Template Syntax
								
							
							
	



						
						
	
				
						Template expressions reference
						
					
			
				
						Template directives reference
- Template expressions reference
- Template directives reference
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
								
							
							
	



						
						
	
				
						Render context
						
					
			
				
						astro:actions
						
					
			
				
						astro:assets
						
					
			
				
						astro:config
						
					
			
				
						astro:content
						
					
			
				
						astro:env
						
					
			
				
						astro:i18n
						
					
			
				
						astro:middleware
						
					
			
				
						astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
								
							
							
	



						
						
	
				
						Integration API
						
					
			
				
						Adapter API
						
					
			
				
						Content Loader API
						
					
			
				
						Image Service API
						
					
			
				
						Dev Toolbar App API
						
					
			
				
						Container API (experimental)
						
					
			
				
						Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
								
							
							
	



						
						
	
				
						Configuring experimental flags
						
					
			
				
						Content Security Policy
						
					
			
				
						Fonts
						
					
			
				
						Live content collections
						
					
			
				
						Client prerendering
						
					
			
				
						Intellisense for collections
						
					
			
				
						Preserve scripts order
						
					
			
				
						Markdown heading ID compatibility
						
					
			
				
						Private meta environment variables inlining
						
					
			
				
						Chrome DevTools workspace
						
					
			
				
						Prerender conflict error
						
					
			
				
						SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- Where to store images
				
				
	
				
					src/ vs public/
				
				
			
				
					Remote images
- src/ vs public/
- Remote images
- Images in .astro files
- Images in Markdown files
- Images in MDX files
- Images in UI framework components
- Astro components for images
				
				
	
				
					<Image />
				
				
			
				
					<Picture />
				
				
			
				
					Responsive image behavior
				
				
			
				
					SVG components
				
				
			
				
					Creating custom image components
- <Image />
- <Picture />
- Responsive image behavior
- SVG components
- Creating custom image components
- Display unprocessed images with the HTML <img> tag
				
				
	
				
					images in src/
				
				
			
				
					Images in public/
				
				
			
				
					Remote images
				
				
			
				
					Choosing <Image /> vs <img>
- images in src/
- Images in public/
- Remote images
- Choosing <Image /> vs <img>
- Using Images from a CMS or CDN
- Authorizing remote images
- Images in content collections
- Generating images with getImage()
- Alt Text
- Default image service
				
				
	
				
					Configure no-op passthrough service
- Configure no-op passthrough service
- Asset Caching
				
				
	
				
					Remote Images
- Remote Images
- Community Integrations
## On this page

- Overview
- Where to store images
src/ vs public/
Remote images
- src/ vs public/
- Remote images
- Images in .astro files
- Images in Markdown files
- Images in MDX files
- Images in UI framework components
- Astro components for images
<Image />
<Picture />
Responsive image behavior
SVG components
Creating custom image components
- <Image />
- <Picture />
- Responsive image behavior
- SVG components
- Creating custom image components
- Display unprocessed images with the HTML <img> tag
images in src/
Images in public/
Remote images
Choosing <Image /> vs <img>
- images in src/
- Images in public/
- Remote images
- Choosing <Image /> vs <img>
- Using Images from a CMS or CDN
- Authorizing remote images
- Images in content collections
- Generating images with getImage()
- Alt Text
- Default image service
Configure no-op passthrough service
- Configure no-op passthrough service
- Asset Caching
Remote Images
- Remote Images
- Community Integrations
## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

# Images

Astro provides several ways for you to use images on your site, whether they are stored locally inside your project, linked to from an external URL, or managed in a CMS or CDN.

Astro provides built-in <Image /> and <Picture /> Astro components, Markdown image syntax (![]()) processing, SVG components, and an image generating function to optimize and/or transform your images. Additionally, you can configure automatically resizing responsive images by default, or set responsive properties on individual image and picture components.

```
<Image />
```

```
<Picture />
```

```
![]()
```

You can always choose to use images and SVG files using native HTML elements in .astro or Markdown files, or the standard way for your file type (e.g. <img /> in MDX and JSX). However, Astro does not perform any processing or optimization of these images.

```
.astro
```

```
<img />
```

There is also no native video support in Astro, and we recommend choosing a hosted video service to handle the demands of optimizing and streaming video content.

```
<Image />
```

```
<Picture />
```

## Where to store images

### src/ vs public/

```
src/
```

```
public/
```

We recommend that local images are kept in src/ when possible so that Astro can transform, optimize, and bundle them. Files in the public/ directory are always served or copied into the build folder as-is, with no processing.

```
src/
```

```
public/
```

Your local images stored in src/ can be used by all files in your project: .astro, .md, .mdx, .mdoc, and other UI frameworks as file imports. Images can be stored in any folder, including alongside your content.

```
src/
```

```
.astro
```

```
.md
```

```
.mdx
```

```
.mdoc
```

Store your images in the public/ folder if you want to avoid any processing. These images are available to your project files as URL paths on your domain and allow you to have a direct public link to them. For example, your site favicon will commonly be placed in the root of this folder where browsers can identify it.

```
public/
```

### Remote images

You can also choose to store your images remotely, in a content management system (CMS) or digital asset management (DAM) platform. Astro can fetch your data remotely using APIs or display images from their full URL path.

For extra protection when dealing with external sources, Astro’s image components and helper function will only process (e.g. optimize, transform) images from authorized image sources specified in your configuration. Remote images from other sources will be displayed with no processing.

## Images in .astro files

```
.astro
```

Options: <Image />, <Picture />, <img>, <svg>, SVG components

```
<Image />
```

```
<Picture />
```

```
<img>
```

```
<svg>
```

Astro’s templating language allows you to render optimized images with the Astro <Image /> component and generate multiple sizes and formats with the Astro <Picture /> component. Both components also accept responsive image properties for resizing based on container size and responding to device screen size and resolution.

```
<Image />
```

```
<Picture />
```

Additionally, you can import and use SVG files as Astro components in .astro components.

```
.astro
```

All native HTML tags, including <img> and <svg>, are also available in .astro components. Images rendered with HTML tags will not be processed (e.g. optimized, transformed) and will be copied into your build folder as-is.

```
<img>
```

```
<svg>
```

```
.astro
```

For all images in .astro files, the value of the image src attribute is determined by the location of your image file:

```
.astro
```

```
src
```

- A local image from your project src/ folder uses an import from the file’s relative path.

The image and picture components use the named import directly (e.g. src={rocket}), while the <img> tag uses the src object property of the import (e.g. src={rocket.src}).
A local image from your project src/ folder uses an import from the file’s relative path.

```
src/
```

The image and picture components use the named import directly (e.g. src={rocket}), while the <img> tag uses the src object property of the import (e.g. src={rocket.src}).

```
src={rocket}
```

```
<img>
```

```
src
```

```
src={rocket.src}
```

- Remote and public/ images use a URL path.

Provide a full URL for remote images (e.g. src="https://www.example.com/images/my-remote-image.jpg"), or a relative URL path on your site that corresponds to your file’s location in your public/ folder (e.g. src="/images/my-public-image.jpg" for an image located in public/images/my-public-image.jpg).
Remote and public/ images use a URL path.

```
public/
```

Provide a full URL for remote images (e.g. src="https://www.example.com/images/my-remote-image.jpg"), or a relative URL path on your site that corresponds to your file’s location in your public/ folder (e.g. src="/images/my-public-image.jpg" for an image located in public/images/my-public-image.jpg).

```
src="https://www.example.com/images/my-remote-image.jpg"
```

```
public/
```

```
src="/images/my-public-image.jpg"
```

```
public/images/my-public-image.jpg
```

```
---
import { Image } from 'astro:assets';
import localBirdImage from '../../images/subfolder/localBirdImage.png';
---
<Image src={localBirdImage} alt="A bird sitting on a nest of eggs." />
<Image src="/images/bird-in-public-folder.jpg" alt="A bird." width="50" height="50" />
<Image src="https://example.com/remote-bird.jpg" alt="A bird." width="50" height="50" />


<img src={localBirdImage.src} alt="A bird sitting on a nest of eggs.">
<img src="/images/bird-in-public-folder.jpg" alt="A bird.">
<img src="https://example.com/remote-bird.jpg" alt="A bird.">
```

```
---
import { Image } from 'astro:assets';
import localBirdImage from '../../images/subfolder/localBirdImage.png';
---
<Image src={localBirdImage} alt="A bird sitting on a nest of eggs." />
<Image src="/images/bird-in-public-folder.jpg" alt="A bird." width="50" height="50" />
<Image src="https://example.com/remote-bird.jpg" alt="A bird." width="50" height="50" />


<img src={localBirdImage.src} alt="A bird sitting on a nest of eggs.">
<img src="/images/bird-in-public-folder.jpg" alt="A bird.">
<img src="https://example.com/remote-bird.jpg" alt="A bird.">
```

```
<Image />
```

```
<Picture />
```

## Images in Markdown files

Options: ![](), <img> (with public or remote images)

```
![]()
```

```
<img>
```

Use standard Markdown ![alt](src) syntax in your .md files. Your local images stored in src/ and remote images will be processed and optimized. When you configure responsive images globally, these images will also be responsive.

```
![alt](src)
```

```
.md
```

```
src/
```

Images stored in the public/ folder are never optimized.

```
public/
```

```
# My Markdown Page


<!-- Local image stored in src/assets/ -->
<!-- Use a relative file path or import alias -->
![A starry night sky.](../assets/stars.png)


<!-- Image stored in public/images/ -->
<!-- Use the file path relative to public/ -->
![A starry night sky.](/images/stars.png)


<!-- Remote image on another server -->
<!-- Use the full URL of the image -->
![Astro](https://example.com/images/remote-image.png)
```

```
# My Markdown Page


<!-- Local image stored in src/assets/ -->
<!-- Use a relative file path or import alias -->
![A starry night sky.](../assets/stars.png)


<!-- Image stored in public/images/ -->
<!-- Use the file path relative to public/ -->
![A starry night sky.](/images/stars.png)


<!-- Remote image on another server -->
<!-- Use the full URL of the image -->
![Astro](https://example.com/images/remote-image.png)
```

The HTML <img> tag can also be used to display images stored in public/ or remote images without any image optimization or processing. However, <img> is not supported for your local images in src.

```
<img>
```

```
public/
```

```
<img>
```

```
src
```

The <Image /> and <Picture /> components are unavailable in .md files. If you require more control over your image attributes, we recommend using Astro’s MDX integration to add support for .mdx file format. MDX allows additional image options available in MDX, including combining components with Markdown syntax.

```
<Image />
```

```
<Picture />
```

```
.md
```

```
.mdx
```

## Images in MDX files

Options: <Image />, <Picture />, <img />, ![](), SVG components

```
<Image />
```

```
<Picture />
```

```
<img />
```

```
![]()
```

You can use Astro’s <Image /> and <Picture /> components in your .mdx files by importing both the component and your image. Use them just as they are used in .astro files. The JSX <img /> tag is also supported for unprocessed images and uses the same image import as the HTML <img> tag.

```
<Image />
```

```
<Picture />
```

```
.mdx
```

```
.astro
```

```
<img />
```

```
<img>
```

Additionally, there is support for standard Markdown ![alt](src) syntax with no import required.

```
![alt](src)
```

```
---
title: My Page title
---
import { Image } from 'astro:assets';
import rocket from '../assets/rocket.png';


# My MDX Page


// Local image stored in the the same folder
![Houston in the wild](houston.png)


// Local image stored in src/assets/
<Image src={rocket} alt="A rocketship in space." />
<img src={rocket.src} alt="A rocketship in space." />
![A rocketship in space](../assets/rocket.png)


// Image stored in public/images/
<Image src="/images/stars.png" alt="A starry night sky." />
<img src="/images/stars.png" alt="A starry night sky." />
![A starry night sky.](/images/stars.png)


// Remote image on another server
<Image src="https://example.com/images/remote-image.png" />
<img src="https://example.com/images/remote-image.png" />
![Astro](https://example.com/images/remote-image.png)
```

```
---
title: My Page title
---
import { Image } from 'astro:assets';
import rocket from '../assets/rocket.png';


# My MDX Page


// Local image stored in the the same folder
![Houston in the wild](houston.png)


// Local image stored in src/assets/
<Image src={rocket} alt="A rocketship in space." />
<img src={rocket.src} alt="A rocketship in space." />
![A rocketship in space](../assets/rocket.png)


// Image stored in public/images/
<Image src="/images/stars.png" alt="A starry night sky." />
<img src="/images/stars.png" alt="A starry night sky." />
![A starry night sky.](/images/stars.png)


// Remote image on another server
<Image src="https://example.com/images/remote-image.png" />
<img src="https://example.com/images/remote-image.png" />
![Astro](https://example.com/images/remote-image.png)
```

```
<Image />
```

```
<Picture />
```

## Images in UI framework components

Image options: the framework’s own image syntax (e.g. <img /> in JSX, <img> in Svelte)

```
<img />
```

```
<img>
```

Local images must first be imported to access their image properties such as src. Then, they can be rendered as you normally would in that framework’s own image syntax:

```
src
```

```
import stars from "../assets/stars.png";


export default function ReactImage() {
  return (
    <img src={stars.src} alt="A starry night sky." />
  )
}
```

```
import stars from "../assets/stars.png";


export default function ReactImage() {
  return (
    <img src={stars.src} alt="A starry night sky." />
  )
}
```

```
<script>
  import stars from '../assets/stars.png';
</script>


<img src={stars.src} alt="A starry night sky." />
```

```
<script>
  import stars from '../assets/stars.png';
</script>


<img src={stars.src} alt="A starry night sky." />
```

Astro components (e.g. <Image />, <Picture />, SVG components) are unavailable inside UI framework components because a client island must contain only valid code for its own framework.

```
<Image />
```

```
<Picture />
```

But, you can pass the static content generated by these components to a framework component inside a .astro file as children or using a named <slot/>:

```
.astro
```

```
<slot/>
```

```
---
import ReactComponent from './ReactComponent.jsx';
import { Image } from 'astro:assets';
import stars from '~/stars/docline.png';
---


<ReactComponent>
  <Image src={stars} alt="A starry night sky." />
</ReactComponent>
```

```
---
import ReactComponent from './ReactComponent.jsx';
import { Image } from 'astro:assets';
import stars from '~/stars/docline.png';
---


<ReactComponent>
  <Image src={stars} alt="A starry night sky." />
</ReactComponent>
```

## Astro components for images

Astro provides two built-in Astro components for images (<Image /> and <Picture />) and also allows you to import SVG files and use them as Astro components. These components may be used in any files that can import and render .astro components.

```
<Image />
```

```
<Picture />
```

```
.astro
```

### <Image />

```
<Image />
```

Use the built-in <Image /> Astro component to display optimized versions of:

```
<Image />
```

- your local images located within the src/ folder
```
src/
```

- configured remote images from authorized sources
<Image /> can transform a local or authorized remote image’s dimensions, file type, and quality for control over your displayed image. This transformation happens at build time for prerendered pages. When your page is rendered on demand, this transformation will occur on the fly when the page is viewed. The resulting <img> tag includes alt, loading, and decoding attributes and infers image dimensions to avoid Cumulative Layout Shift (CLS).

```
<Image />
```

```
<img>
```

```
alt
```

```
loading
```

```
decoding
```

What is Cumulative Layout Shift?

Cumulative Layout Shift (CLS) is a Core Web Vital metric for measuring how much content shifted on your page during loading. The <Image /> component optimizes for CLS by automatically setting the correct width and height for your images.

```
<Image />
```

```
width
```

```
height
```

```
---
// import the Image component and the image
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png'; // Image is 1600x900
---


<!-- `alt` is mandatory on the Image component -->
<Image src={myImage} alt="A description of my image." />
```

```
---
// import the Image component and the image
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png'; // Image is 1600x900
---


<!-- `alt` is mandatory on the Image component -->
<Image src={myImage} alt="A description of my image." />
```

```
<!-- Prerendered output -->
<!-- Image is optimized, proper attributes are enforced -->
<img
  src="/_astro/my_image.hash.webp"
  width="1600"
  height="900"
  decoding="async"
  loading="lazy"
  alt="A description of my image."
/>


<!-- Output rendered on demand-->
<!-- src will use an endpoint generated on demand-->
<img
  src="/_image?href=%2F_astro%2Fmy_image.hash.webp&amp;w=1600&amp;h=900&amp;f=webp"
  <!-- ... -->
/>
```

```
<!-- Prerendered output -->
<!-- Image is optimized, proper attributes are enforced -->
<img
  src="/_astro/my_image.hash.webp"
  width="1600"
  height="900"
  decoding="async"
  loading="lazy"
  alt="A description of my image."
/>


<!-- Output rendered on demand-->
<!-- src will use an endpoint generated on demand-->
<img
  src="/_image?href=%2F_astro%2Fmy_image.hash.webp&amp;w=1600&amp;h=900&amp;f=webp"
  <!-- ... -->
/>
```

The <Image /> component accepts several component properties as well as any attributes accepted by the HTML <img> tag.

```
<Image />
```

```
<img>
```

The following example provides a class to the image component which will apply to the final <img> element.

```
class
```

```
<img>
```

```
---
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png';
---


<!-- `alt` is mandatory on the Image component -->
<Image src={myImage} alt="" class="my-class" />
```

```
---
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png';
---


<!-- `alt` is mandatory on the Image component -->
<Image src={myImage} alt="" class="my-class" />
```

```
<!-- Prerendered output -->
<img
  src="/_astro/my_image.hash.webp"
  width="1600"
  height="900"
  decoding="async"
  loading="lazy"
  class="my-class"
  alt=""
/>
```

```
<!-- Prerendered output -->
<img
  src="/_astro/my_image.hash.webp"
  width="1600"
  height="900"
  decoding="async"
  loading="lazy"
  class="my-class"
  alt=""
/>
```

Tip

You can also use the <Image /> component for images in the public/ folder, or remote images not specifically configured in your project, even though these images will not be optimized or processed. The resulting image will be the same as using the HTML <img>.

```
<Image />
```

```
public/
```

```
<img>
```

However, using the image component for all images provides a consistent authoring experience and prevents Cumulative Layout Shift (CLS) even for your unoptimized images.

### <Picture />

```
<Picture />
```

Added in: astro@3.3.0

```
astro@3.3.0
```

Use the built-in <Picture /> Astro component to generate a <picture> tag with multiple formats and/or sizes of your image. This allows you to specify preferred file formats to display and at the same time, provide a fallback format. Like the <Image /> component, images will be processed at build time for prerendered pages. When your page is rendered on demand, processing will occur on the fly when the page is viewed.

```
<Picture />
```

```
<picture>
```

```
<Image />
```

The following example uses the <Picture /> component to transform a local .png file into a web-friendly avif and webp format as well as the .png <img> that can be displayed as a fallback when needed:

```
<Picture />
```

```
.png
```

```
avif
```

```
webp
```

```
.png
```

```
<img>
```

```
---
import { Picture } from 'astro:assets';
import myImage from '../assets/my_image.png'; // Image is 1600x900
---


<!-- `alt` is mandatory on the Picture component -->
<Picture src={myImage} formats={['avif', 'webp']} alt="A description of my image." />
```

```
---
import { Picture } from 'astro:assets';
import myImage from '../assets/my_image.png'; // Image is 1600x900
---


<!-- `alt` is mandatory on the Picture component -->
<Picture src={myImage} formats={['avif', 'webp']} alt="A description of my image." />
```

```
<!-- Prerendered output -->
<picture>
  <source srcset="/_astro/my_image.hash.avif" type="image/avif" />
  <source srcset="/_astro/my_image.hash.webp" type="image/webp" />
  <img
    src="/_astro/my_image.hash.png"
    width="1600"
    height="900"
    decoding="async"
    loading="lazy"
    alt="A description of my image."
  />
</picture>
```

```
<!-- Prerendered output -->
<picture>
  <source srcset="/_astro/my_image.hash.avif" type="image/avif" />
  <source srcset="/_astro/my_image.hash.webp" type="image/webp" />
  <img
    src="/_astro/my_image.hash.png"
    width="1600"
    height="900"
    decoding="async"
    loading="lazy"
    alt="A description of my image."
  />
</picture>
```

```
<Picture />
```

```
astro:assets
```

### Responsive image behavior

Added in: astro@5.10.0

```
astro@5.10.0
```

Responsive images are images that adjust to improve performance across different devices. These images can resize to fit their container, and can be served in different sizes depending on your visitor’s screen size and resolution.

With responsive image properties applied to the <Image /> or <Picture /> components, Astro will automatically generate the required srcset and sizes values for your images, and apply the necessary styles to ensure they resize correctly.

```
<Image />
```

```
<Picture />
```

```
srcset
```

```
sizes
```

When this responsive behavior is configured globally with image.layout, it will apply to all image components and also to any local and remote images using the Markdown ![]() syntax.

```
image.layout
```

```
![]()
```

Images in your public/ folder are never optimized, and responsive images are not supported.

```
public/
```

Note

A single responsive image will generate multiple images of different sizes so that the browser can show the best one to your visitor.

For prerendered pages, this happens during the build and may increase the build time of your project, especially if you have a large number of images.

For pages rendered on-demand, the images are generated as-needed when a page is visited. This has no impact on build times but may increase the number of image transformations performed when an image is displayed. Depending on your image service this may incur additional costs.

#### Generated HTML output for responsive images

When a layout is set, either by default or on an individual component, images have automatically generated srcset and sizes attributes based on the image’s dimensions and the layout type. Images with constrained and full-width layouts will have styles applied to ensure they resize according to their container.

```
srcset
```

```
sizes
```

```
constrained
```

```
full-width
```

```
---
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png';
---
<Image src={myImage} alt="A description of my image." layout='constrained' width={800} height={600} />
```

```
---
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png';
---
<Image src={myImage} alt="A description of my image." layout='constrained' width={800} height={600} />
```

This <Image /> component will generate the following HTML output on a prerendered page:

```
<Image />
```

```
<img
  src="/_astro/my_image.hash3.webp"
  srcset="/_astro/my_image.hash1.webp 640w,
      /_astro/my_image.hash2.webp 750w,
      /_astro/my_image.hash3.webp 800w,
      /_astro/my_image.hash4.webp 828w,
      /_astro/my_image.hash5.webp 1080w,
      /_astro/my_image.hash6.webp 1280w,
      /_astro/my_image.hash7.webp 1600w"
  alt="A description of my image"
  sizes="(min-width: 800px) 800px, 100vw"
  loading="lazy"
  decoding="async"
  fetchpriority="auto"
  width="800"
  height="600"
  style="--fit: cover; --pos: center;"
  data-astro-image="constrained"
>
```

```
<img
  src="/_astro/my_image.hash3.webp"
  srcset="/_astro/my_image.hash1.webp 640w,
      /_astro/my_image.hash2.webp 750w,
      /_astro/my_image.hash3.webp 800w,
      /_astro/my_image.hash4.webp 828w,
      /_astro/my_image.hash5.webp 1080w,
      /_astro/my_image.hash6.webp 1280w,
      /_astro/my_image.hash7.webp 1600w"
  alt="A description of my image"
  sizes="(min-width: 800px) 800px, 100vw"
  loading="lazy"
  decoding="async"
  fetchpriority="auto"
  width="800"
  height="600"
  style="--fit: cover; --pos: center;"
  data-astro-image="constrained"
>
```

#### Responsive image styles

Setting image.responsiveStyles: true applies a small number of global styles to ensure that your images resize correctly. In most cases, you will want to enable these as a default; your images will not be responsive without additional styles.

```
image.responsiveStyles: true
```

However, if you prefer to handle responsive image styling yourself, or need to override these defaults when using Tailwind 4, leave the default false value configured.

```
false
```

The global styles applied by Astro will depend on the layout type, and are designed to produce the best result for the generated srcset and sizes attributes. These are the default styles:

```
srcset
```

```
sizes
```

```
:where([data-astro-image]) {
  object-fit: var(--fit);
  object-position: var(--pos);
}
:where([data-astro-image='full-width']) {
  width: 100%;
}
:where([data-astro-image='constrained']) {
  max-width: 100%;
}
```

```
:where([data-astro-image]) {
  object-fit: var(--fit);
  object-position: var(--pos);
}
:where([data-astro-image='full-width']) {
  width: 100%;
}
:where([data-astro-image='constrained']) {
  max-width: 100%;
}
```

The styles use the :where() pseudo-class, which has a specificity of 0, meaning that it is easy to override with your own styles. Any CSS selector will have a higher specificity than :where(), so you can easily override the styles by adding your own styles to target the image.

```
:where()
```

```
:where()
```

You can override the object-fit and object-position styles on a per-image basis by setting the fit and position props on the <Image /> or <Picture /> component.

```
object-fit
```

```
object-position
```

```
fit
```

```
position
```

```
<Image />
```

```
<Picture />
```

#### Responsive images with Tailwind 4

Tailwind 4 is compatible with Astro’s default responsive styles. However, Tailwind uses cascade layers, meaning that its rules are always lower specificity than rules that don’t use layers, including Astro’s responsive styles. Therefore, Astro’s styling will take precedence over Tailwind styling. To use Tailwind rules instead of Astro’s default styling, do not enable Astro’s default responsive styles.

### SVG components

Added in: astro@5.7.0

```
astro@5.7.0
```

Astro allows you to import SVG files and use them as Astro components. Astro will inline the SVG content into your HTML output.

Reference the default import of any local .svg file. Since this import is treated as an Astro component, you must use the same conventions (e.g. capitalization) as when using dynamic tags.

```
.svg
```

```
---
import Logo from './path/to/svg/file.svg';
---


<Logo />
```

```
---
import Logo from './path/to/svg/file.svg';
---


<Logo />
```

Your SVG component, like <Image /> or any other Astro component, is unavailable inside UI framework components, but can be passed to a framework component inside a .astro component.

```
<Image />
```

```
.astro
```

#### SVG component attributes

You can pass props such as width, height, fill, stroke, and any other attribute accepted by the native <svg> element. These attributes will automatically be applied to the underlying <svg> element. If a property is present in the original .svg file and is passed to the component, the value passed to the component will override the original value.

```
width
```

```
height
```

```
fill
```

```
stroke
```

```
<svg>
```

```
<svg>
```

```
.svg
```

```
---
import Logo from '../assets/logo.svg';
---


<Logo width={64} height={64} fill="currentColor" />
```

```
---
import Logo from '../assets/logo.svg';
---


<Logo width={64} height={64} fill="currentColor" />
```

#### SvgComponent Type

```
SvgComponent
```

```
astro@5.14.0
```

You can also enforce type safety for your .svg assets using the SvgComponent type:

```
.svg
```

```
SvgComponent
```

```
---
import type { SvgComponent } from "astro/types";
import HomeIcon from './Home.svg'


interface Link {
  url: string
  text: string
  icon: SvgComponent
}


const links: Link[] = [
  {
    url: '/',
    text: 'Home',
    icon: HomeIcon
  }
]
---
```

```
---
import type { SvgComponent } from "astro/types";
import HomeIcon from './Home.svg'


interface Link {
  url: string
  text: string
  icon: SvgComponent
}


const links: Link[] = [
  {
    url: '/',
    text: 'Home',
    icon: HomeIcon
  }
]
---
```

### Creating custom image components

You can create a custom, reusable image component by wrapping the <Image /> or <Picture/> component in another Astro component. This allows you to set default attributes and styles only once.

```
<Image />
```

```
<Picture/>
```

For example, you could create a component for your blog post images that receives attributes as props and applies consistent styles to each image:

```
---
import { Image } from 'astro:assets';


const { src, ...attrs } = Astro.props;
---
<Image src={src} {...attrs} />


<style>
  img {
    margin-block: 2.5rem;
    border-radius: 0.75rem;
  }
</style>
```

```
---
import { Image } from 'astro:assets';


const { src, ...attrs } = Astro.props;
---
<Image src={src} {...attrs} />


<style>
  img {
    margin-block: 2.5rem;
    border-radius: 0.75rem;
  }
</style>
```

## Display unprocessed images with the HTML <img> tag

```
<img>
```

The Astro template syntax also supports writing an <img> tag directly, with full control over its final output. These images will not be processed and optimized. It accepts all HTML <img> tag properties, and the only required property is src. However, it is strongly recommended to include the alt property for accessibility.

```
<img>
```

```
<img>
```

```
src
```

```
alt
```

### images in src/

```
src/
```

Local images must be imported from the relative path from the existing .astro file, or you can configure and use an import alias. Then, you can access the image’s src and other properties to use in the <img> tag.

```
.astro
```

```
src
```

```
<img>
```

Imported image assets match the following signature:

```
interface ImageMetadata {
  src: string;
  width: number;
  height: number;
  format: string;
}
```

```
interface ImageMetadata {
  src: string;
  width: number;
  height: number;
  format: string;
}
```

The following example uses the image’s own height and width properties to avoid Cumulative Layout Shift (CLS) and improve Core Web Vitals:

```
height
```

```
width
```

```
---
// import local images
import myDog from '../../images/pets/local-dog.jpg';
---
// access the image properties
<img src={myDog.src} width={myDog.width} height={myDog.height} alt="A barking dog." />
```

```
---
// import local images
import myDog from '../../images/pets/local-dog.jpg';
---
// access the image properties
<img src={myDog.src} width={myDog.width} height={myDog.height} alt="A barking dog." />
```

### Images in public/

```
public/
```

For images located within public/ use the image’s file path relative to the public folder as the src value:

```
public/
```

```
src
```

```
<img src="/images/public-cat.jpg" alt="A sleeping cat." >
```

```
<img src="/images/public-cat.jpg" alt="A sleeping cat." >
```

### Remote images

For remote images, use the image’s full URL as the src value:

```
src
```

```
<img src="https://example.com/remote-cat.jpg" alt="A sleeping cat." >
```

```
<img src="https://example.com/remote-cat.jpg" alt="A sleeping cat." >
```

### Choosing <Image /> vs <img>

```
<Image />
```

```
<img>
```

The <Image /> component optimizes your image and infers width and height (for images it can process) based on the original aspect ratio to avoid CLS. It is the preferred way to use images in .astro files whenever possible.

```
<Image />
```

```
.astro
```

Use the HTML <img> element when you cannot use the <Image /> component, for example:

```
<img>
```

```
<Image />
```

- for unsupported image formats
- when you do not want your image optimized by Astro
- to access and change the src attribute dynamically client-side
```
src
```

## Using Images from a CMS or CDN

Image CDNs work with all Astro image options. Use an image’s full URL as the src attribute in the <Image /> component, an <img> tag, or in Markdown notation. For image optimization with remote images, also configure your authorized domains or URL patterns.

```
src
```

```
<Image />
```

```
<img>
```

Alternatively, the CDN may provide its own SDKs to more easily integrate in an Astro project. For example, Cloudinary supports an Astro SDK which allows you to easily drop in images with their CldImage component or a Node.js SDK that can generate URLs to use with an <img> tag in a Node.js environment.

```
CldImage
```

```
<img>
```

```
<Image />
```

```
<Picture />
```

## Authorizing remote images

You can configure lists of authorized image source URL domains and patterns for image optimization using image.domains and image.remotePatterns. This configuration is an extra layer of safety to protect your site when showing images from an external source.

```
image.domains
```

```
image.remotePatterns
```

Remote images from other sources will not be optimized, but using the <Image /> component for these images will prevent Cumulative Layout Shift (CLS).

```
<Image />
```

For example, the following configuration will only allow remote images from astro.build to be optimized:

```
astro.build
```

```
export default defineConfig({
  image: {
    domains: ["astro.build"],
  }
});
```

```
export default defineConfig({
  image: {
    domains: ["astro.build"],
  }
});
```

The following configuration will only allow remote images from HTTPS hosts:

```
export default defineConfig({
  image: {
    remotePatterns: [{ protocol: "https" }],
  }
});
```

```
export default defineConfig({
  image: {
    remotePatterns: [{ protocol: "https" }],
  }
});
```

## Images in content collections

You can declare an associated image for a content collections entry, such as a blog post’s cover image, in your frontmatter using its path relative to the current folder:

```
---
title: "My first blog post"
cover: "./firstpostcover.jpeg" # will resolve to "src/content/blog/firstblogcover.jpeg"
coverAlt: "A photograph of a sunset behind a mountain range."
---


This is a blog post
```

```
---
title: "My first blog post"
cover: "./firstpostcover.jpeg" # will resolve to "src/content/blog/firstblogcover.jpeg"
coverAlt: "A photograph of a sunset behind a mountain range."
---


This is a blog post
```

The image helper for the content collections schema lets you validate and import the image.

```
image
```

```
import { defineCollection, z } from "astro:content";


const blogCollection = defineCollection({
  schema: ({ image }) => z.object({
    title: z.string(),
    cover: image(),
    coverAlt: z.string(),
  }),
});


export const collections = {
  blog: blogCollection,
};
```

```
import { defineCollection, z } from "astro:content";


const blogCollection = defineCollection({
  schema: ({ image }) => z.object({
    title: z.string(),
    cover: image(),
    coverAlt: z.string(),
  }),
});


export const collections = {
  blog: blogCollection,
};
```

The image will be imported and transformed into metadata, allowing you to pass it as a src to <Image/>, <img>, or getImage() in an Astro component.

```
src
```

```
<Image/>
```

```
<img>
```

```
getImage()
```

The example below shows a blog index page that renders the cover photo and title of each blog post from the previous schema:

```
---
import { Image } from "astro:assets";
import { getCollection } from "astro:content";
const allBlogPosts = await getCollection("blog");
---


{
  allBlogPosts.map((post) => (
    <div>
      <Image src={post.data.cover} alt={post.data.coverAlt} />
      <h2>
        <a href={"/blog/" + post.slug}>{post.data.title}</a>
      </h2>
    </div>
  ))
}
```

```
---
import { Image } from "astro:assets";
import { getCollection } from "astro:content";
const allBlogPosts = await getCollection("blog");
---


{
  allBlogPosts.map((post) => (
    <div>
      <Image src={post.data.cover} alt={post.data.coverAlt} />
      <h2>
        <a href={"/blog/" + post.slug}>{post.data.title}</a>
      </h2>
    </div>
  ))
}
```

## Generating images with getImage()

```
getImage()
```

The getImage() function is intended for generating images destined to be used somewhere else than directly in HTML, for example in an API Route. When you need options that the <Picture> and <Image> components do not currently support, you can use the getImage() function to create your own custom <Image /> component.

```
getImage()
```

```
<Picture>
```

```
<Image>
```

```
getImage()
```

```
<Image />
```

```
getImage()
```

## Alt Text

Not all users can see images in the same way, so accessibility is an especially important concern when using images. Use the alt attribute to provide descriptive alt text for images.

```
alt
```

This attribute is required for both the <Image /> and <Picture /> components. If no alt text is provided, a helpful error message will be provided reminding you to include the alt attribute.

```
<Image />
```

```
<Picture />
```

```
alt
```

If the image is merely decorative (i.e. doesn’t contribute to the understanding of the page), set alt="" so that screen readers know to ignore the image.

```
alt=""
```

## Default image service

Sharp is the default image service used for astro:assets. You can further configure the image service using the image.service option.

```
astro:assets
```

```
image.service
```

Note

When using a strict package manager like pnpm, you may need to manually install Sharp into your project even though it is an Astro dependency:

```
pnpm
```

```
pnpm add sharp
```

```
pnpm add sharp
```

### Configure no-op passthrough service

If your adapter does not support Astro’s built-in Sharp image optimization (e.g. Deno, Cloudflare), you can configure a no-op image service to allow you to use the <Image /> and <Picture /> components. Note that Astro does not perform any image transformation and processing in these environments. However, you can still enjoy the other benefits of using astro:assets, including no Cumulative Layout Shift (CLS), the enforced alt attribute, and a consistent authoring experience.

```
<Image />
```

```
<Picture />
```

```
astro:assets
```

```
alt
```

Configure the passthroughImageService() to avoid Sharp image processing:

```
passthroughImageService()
```

```
import { defineConfig, passthroughImageService } from 'astro/config';


export default defineConfig({
  image: {
    service: passthroughImageService()
  }
});
```

```
import { defineConfig, passthroughImageService } from 'astro/config';


export default defineConfig({
  image: {
    service: passthroughImageService()
  }
});
```

## Asset Caching

Astro stores processed image assets in a cache directory during site builds for both local and remote images from authorized sources. By preserving the cache directory between builds, processed assets are reused, improving build time and bandwidth usage.

The default cache directory is ./node_modules/.astro, however this can be changed using the cacheDir configuration setting.

```
./node_modules/.astro
```

```
cacheDir
```

### Remote Images

Remote images in the asset cache are managed based on HTTP Caching, and respect the Cache-Control header returned by the remote server. Images are cached if the Cache-Control header allows, and will be used until they are no longer fresh.

#### Revalidation

Added in: astro@5.1.0

```
astro@5.1.0
```

Revalidation reduces bandwidth usage and build time by checking with the remote server whether an expired cached image is still up-to-date. If the server indicates that the image is still fresh, the cached version is reused, otherwise the image is redownloaded.

Revalidation requires that the remote server send Last-Modified and/or Etag (entity tag) headers with its responses. This feature is available for remote servers that support the If-Modified-Since and If-None-Match headers.

## Community Integrations

There are several third-party community image integrations for optimizing and working with images in your Astro project.

## Learn Astro with Coding in Public

150+ video lessons
			
			•
			Astro v5 ready

