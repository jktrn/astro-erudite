- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
								
							
							
	



						
						
	
				
						Pages
						
					
			
				
						Routing
						
					
			
				
						Endpoints
						
					
			
				
						Middleware
						
					
			
				
						Internationalization (i18n)
						
					
			
				
						Prefetch
						
					
			
				
						View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
								
							
							
	



						
						
	
				
						Components
						
					
			
				
						Layouts
						
					
			
				
						Styles and CSS
						
					
			
				
						Fonts
						
					
			
				
						Syntax Highlighting
						
					
			
				
						Scripts and event handling
						
					
			
				
						Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
								
							
							
	



						
						
	
				
						Markdown
						
					
			
				
						Content collections
						
					
			
				
						Images
						
					
			
				
						Data fetching
						
					
			
				
						Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
								
							
							
	



						
						
	
				
						On-demand rendering
						
					
			
				
						Server islands
						
					
			
				
						Actions
						
					
			
				
						Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
								
							
							
	



						
						
	
				
						Upgrade Astro
						
					
			
				
						
						
							
								Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- Upgrade Astro
- Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- v5.0
- v4.0
- v3.0
- v2.0
- v1.0
- Troubleshooting
- How-to recipes
								
							
							
	



						
						
	
				
						Recipes overview
						
					
			
				
						Installing a Vite or Rollup plugin
						
					
			
				
						Analyze bundle size
						
					
			
				
						Build a custom image component
						
					
			
				
						Build HTML forms in Astro pages
						
					
			
				
						Build forms with API routes
						
					
			
				
						Use Bun with Astro
						
					
			
				
						Call endpoints from the server
						
					
			
				
						Verify a Captcha
						
					
			
				
						Customize file names in the build output
						
					
			
				
						Build your Astro site with Docker
						
					
			
				
						Dynamically import images
						
					
			
				
						Add icons to external links
						
					
			
				
						Add i18n features
						
					
			
				
						Create a dev toolbar app
						
					
			
				
						Add last modified time
						
					
			
				
						Add reading time
						
					
			
				
						Add an RSS feed
						
					
			
				
						Share state between Astro components
						
					
			
				
						Share state between islands
						
					
			
				
						Using streaming to improve page performance
						
					
			
				
						Style rendered Markdown with Tailwind Typography
- Recipes overview
- Installing a Vite or Rollup plugin
- Analyze bundle size
- Build a custom image component
- Build HTML forms in Astro pages
- Build forms with API routes
- Use Bun with Astro
- Call endpoints from the server
- Verify a Captcha
- Customize file names in the build output
- Build your Astro site with Docker
- Dynamically import images
- Add icons to external links
- Add i18n features
- Create a dev toolbar app
- Add last modified time
- Add reading time
- Add an RSS feed
- Share state between Astro components
- Share state between islands
- Using streaming to improve page performance
- Style rendered Markdown with Tailwind Typography
- Contribute to Astro
- Astro Template Syntax
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
Render context
astro:actions
astro:assets
astro:config
astro:content
astro:env
astro:i18n
astro:middleware
astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
Integration API
Adapter API
Content Loader API
Image Service API
Dev Toolbar App API
Container API (experimental)
Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
Configuring experimental flags
Content Security Policy
Fonts
Live content collections
Client prerendering
Intellisense for collections
Preserve scripts order
Markdown heading ID compatibility
Private meta environment variables inlining
Chrome DevTools workspace
Prerender conflict error
SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- What is a loader?
- Built-in loaders
				
				
	
				
					glob() loader
				
				
			
				
					file() loader
- glob() loader
- file() loader
- Loader types
				
				
	
				
					Inline loaders
				
				
			
				
					Object loaders
- Inline loaders
- Object loaders
- Object loader API
				
				
	
				
					The Loader object
				
				
			
				
					LoaderContext
				
				
			
				
					DataStore
				
				
			
				
					DataEntry
- The Loader object
- LoaderContext
- DataStore
- DataEntry
## On this page

- Overview
- What is a loader?
- Built-in loaders
glob() loader
file() loader
- glob() loader
- file() loader
- Loader types
Inline loaders
Object loaders
- Inline loaders
- Object loaders
- Object loader API
The Loader object
LoaderContext
DataStore
DataEntry
- The Loader object
- LoaderContext
- DataStore
- DataEntry
## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

# Astro Content Loader API

Astro’s Content Loader API allows you to load your data from any source, local or remote, and interact with Astro’s content layer to manage your content collections.

## What is a loader?

Astro loaders allow you to load data into content collections, which can then be used in pages and components. The built-in glob() and file() loaders are used to load content from the file system, and you can create your own loaders to load content from other sources.

```
glob()
```

```
file()
```

Each collection needs a loader defined in its schema. You can define a loader inline in your project’s src/content.config.ts file, share one loader between multiple collections, or even publish your loader to NPM as a package to share with others and be included in our integrations library.

```
src/content.config.ts
```

## Built-in loaders

Astro provides two built-in loaders to help you fetch your collections. Both offer options to suit a wide range of use cases.

### glob() loader

```
glob()
```

Type: (options: GlobOptions) => Loader

```
(options: GlobOptions) => Loader
```

```
astro@5.0.0
```

The glob() loader creates entries from directories of files from anywhere on the filesystem. The supported file types are Markdown, MDX, Markdoc, JSON, YAML, and TOML files.

```
glob()
```

This loader accepts an object with the following properties: pattern, base (optional), and generateId (optional).

```
pattern
```

```
base
```

```
generateId
```

```
import { defineCollection } from 'astro:content';
import { glob } from 'astro/loaders';


const pages = defineCollection({
  /* Retrieve all Markdown files in your pages directory. */
  loader: glob({ pattern: "**/*.md", base: "./src/data/pages" }),
  schema: /* ... */
});
const blog = defineCollection({
  /* Retrieve all Markdown and MDX files in your blog directory. */
  loader: glob({ pattern: "**/*.(md|mdx)", base: "./src/data/blog" }),
  schema: /* ... */
});
const authors = defineCollection({
  /* Retrieve all JSON files in your authors directory while retaining
   * uppercase letters in the ID. */
  loader: glob({
    pattern: '**/*.json',
    base: "./src/data/authors",
    generateId: ({ entry }) => entry.replace(/\.json$/, ''),
  }),
  schema: /* ... */
});
```

```
import { defineCollection } from 'astro:content';
import { glob } from 'astro/loaders';


const pages = defineCollection({
  /* Retrieve all Markdown files in your pages directory. */
  loader: glob({ pattern: "**/*.md", base: "./src/data/pages" }),
  schema: /* ... */
});
const blog = defineCollection({
  /* Retrieve all Markdown and MDX files in your blog directory. */
  loader: glob({ pattern: "**/*.(md|mdx)", base: "./src/data/blog" }),
  schema: /* ... */
});
const authors = defineCollection({
  /* Retrieve all JSON files in your authors directory while retaining
   * uppercase letters in the ID. */
  loader: glob({
    pattern: '**/*.json',
    base: "./src/data/authors",
    generateId: ({ entry }) => entry.replace(/\.json$/, ''),
  }),
  schema: /* ... */
});
```

#### pattern

```
pattern
```

Type: string | string[]

```
string | string[]
```

The pattern property accepts a string or an array of strings using glob matching (e.g. wildcards, globstars). The patterns must be relative to the base directory of entry files to match.

```
pattern
```

You can learn more about the syntax to use in the micromatch documentation. You can also verify the validity of your pattern using an online tool like the DigitalOcean Glob Tool.

#### base

```
base
```

Type: string | URL
Default: "."

```
string | URL
```

```
"."
```

A relative path or URL to the directory from which to resolve the pattern.

```
pattern
```

#### generateId()

```
generateId()
```

Type: (options: GenerateIdOptions) => string

```
(options: GenerateIdOptions) => string
```

A callback function that returns a unique string per entry in a collection. It accepts an object as parameter with the following properties:

- entry - the path to the entry file, relative to the base directory
```
entry
```

- base - the base directory URL
```
base
```

- data - the parsed, unvalidated data of the entry
```
data
```

By default it uses github-slugger to generate a slug with kebab-cased words.

```
github-slugger
```

### file() loader

```
file()
```

Type: (fileName: string, options?: FileOptions) => Loader

```
(fileName: string, options?: FileOptions) => Loader
```

```
astro@5.0.0
```

The file() loader creates entries from a single file that contains an array of objects with a unique id field, or an object with IDs as keys and entries as values. It supports JSON, YAML, or TOML files and you can provide a custom parser for data files it cannot parse by default.

```
file()
```

```
id
```

```
parser
```

This loader accepts a fileName property and an optional object as second argument:

```
fileName
```

```
import { defineCollection } from 'astro:content';
import { file } from 'astro/loaders';


const authors = defineCollection({
  /* Retrieve all entries from a JSON file. */
  loader: file("src/data/authors.json"),
  schema: /* ... */
});
const products = defineCollection({
  /* Retrieve all entries from a CSV file using a custom parser. */
  loader: file("src/data/products.csv", {
    parser: (fileContent) => { /* your parser logic */ },
  }),
  schema: /* ... */
});
```

```
import { defineCollection } from 'astro:content';
import { file } from 'astro/loaders';


const authors = defineCollection({
  /* Retrieve all entries from a JSON file. */
  loader: file("src/data/authors.json"),
  schema: /* ... */
});
const products = defineCollection({
  /* Retrieve all entries from a CSV file using a custom parser. */
  loader: file("src/data/products.csv", {
    parser: (fileContent) => { /* your parser logic */ },
  }),
  schema: /* ... */
});
```

#### fileName

```
fileName
```

Type: string

```
string
```

Sets the path to the file to load, relative to the root directory.

#### Options

Type: FileOptions

```
FileOptions
```

An optional object with the following properties:

##### parser()

```
parser()
```

Type: (text: string) => Record<string, Record<string, unknown>> | Array<Record<string, unknown>>

```
(text: string) => Record<string, Record<string, unknown>> | Array<Record<string, unknown>>
```

A callback function to create a collection from a file’s contents. Use it when you need to process file not supported by default (e.g. .csv) or when using nested .json documents.

```
.csv
```

```
.json
```

## Loader types

Loaders can be defined either as a simple function that returns an array of entries or with the more powerful object Content Loader API for more control over the loading process.

### Inline loaders

An inline loader is an async function that returns an array or object containing entries. Use this for simple loaders, particularly those that are defined inline in the src/content.config.ts file.

```
src/content.config.ts
```

The function can be async and must return either an array of entries that each contain a unique id field, or an object where each key is a unique ID and each value is the entry. Whenever the loader is invoked, it will clear the store and reload all the entries.

```
id
```

```
const countries = defineCollection({
  loader: async () => {
    const response = await fetch("https://restcountries.com/v3.1/all");
    const data = await response.json();
    // Must return an array of entries with an id property
    // or an object with IDs as keys and entries as values
    return data.map((country) => ({
      id: country.cca3,
      ...country,
    }));
  },
  schema: /* ... */
});
```

```
const countries = defineCollection({
  loader: async () => {
    const response = await fetch("https://restcountries.com/v3.1/all");
    const data = await response.json();
    // Must return an array of entries with an id property
    // or an object with IDs as keys and entries as values
    return data.map((country) => ({
      id: country.cca3,
      ...country,
    }));
  },
  schema: /* ... */
});
```

### Object loaders

A loader is an object with a load() method that is called at build time to fetch data and update the data store. It allows entries to be updated incrementally, or for the store to be cleared only when necessary. It can also define a schema for the entries, which can be used to validate the data and generate static types.

```
load()
```

The recommended pattern is to define a function that accepts configuration options and returns the loader object, in the same way that you would normally define an Astro integration or Vite plugin.

```
import type { Loader, LoaderContext } from 'astro/loaders';
import { z } from 'astro:content';
import { loadFeedData } from "./feed.js";


// Define any options that the loader needs
export function myLoader(options: { url: string, apiKey: string }): Loader {
  // Configure the loader
  const feedUrl = new URL(options.url);
  // Return a loader object
  return {
    name: "my-loader",
    // Called when updating the collection.
    load: async (context: LoaderContext): Promise<void> => {
      // Load data and update the store
      const response = await loadFeedData(feedUrl, options.apiKey);
    },
    // Optionally, define the schema of an entry.
    // It will be overridden by user-defined schema.
    schema: async () => z.object({
      // ...
    })
  };
}
```

```
import type { Loader, LoaderContext } from 'astro/loaders';
import { z } from 'astro:content';
import { loadFeedData } from "./feed.js";


// Define any options that the loader needs
export function myLoader(options: { url: string, apiKey: string }): Loader {
  // Configure the loader
  const feedUrl = new URL(options.url);
  // Return a loader object
  return {
    name: "my-loader",
    // Called when updating the collection.
    load: async (context: LoaderContext): Promise<void> => {
      // Load data and update the store
      const response = await loadFeedData(feedUrl, options.apiKey);
    },
    // Optionally, define the schema of an entry.
    // It will be overridden by user-defined schema.
    schema: async () => z.object({
      // ...
    })
  };
}
```

These configuration options can then be set when defining a collection:

```
import { defineCollection, z } from 'astro:content';
import myLoader from '../../loader.ts';


const blog = defineCollection({
  loader: myLoader({
    url: "https://api.example.com/posts",
    apiKey: "my-secret",
  }),
  schema: /* ... */
});
```

```
import { defineCollection, z } from 'astro:content';
import myLoader from '../../loader.ts';


const blog = defineCollection({
  loader: myLoader({
    url: "https://api.example.com/posts",
    apiKey: "my-secret",
  }),
  schema: /* ... */
});
```

## Object loader API

The API for inline loaders is very simple, and is shown above. This section shows the API for defining an object loader.

### The Loader object

```
Loader
```

The loader object has the following properties:

#### name

```
name
```

Type: string

```
string
```

A unique name for the loader, used in logs and for conditional loading.

#### load

```
load
```

Type: (context: LoaderContext) => Promise<void>

```
(context: LoaderContext) => Promise<void>
```

An async function that is called at build time to load data and update the store. See LoaderContext for more information.

```
LoaderContext
```

#### schema

```
schema
```

Type: ZodSchema | Promise<ZodSchema> | (() => ZodSchema | Promise<ZodSchema>)

```
ZodSchema | Promise<ZodSchema> | (() => ZodSchema | Promise<ZodSchema>)
```

An optional Zod schema that defines the shape of the entries. It is used to both validate the data and also to generate TypeScript types for the collection.

If a function is provided, it will be called at build time before load() to generate the schema. You can use this to dynamically generate the schema based on the configuration options or by introspecting an API.

```
load()
```

### LoaderContext

```
LoaderContext
```

This object is passed to the load() method of the loader, and contains the following properties:

```
load()
```

#### collection

```
collection
```

Type: string

```
string
```

The unique name of the collection. This is the key in the collections object in the src/content.config.ts file.

```
collections
```

```
src/content.config.ts
```

#### store

```
store
```

Type: DataStore

```
DataStore
```

A database to store the actual data. Use this to update the store with new entries. See DataStore for more information.

```
DataStore
```

#### meta

```
meta
```

Type: MetaStore

```
MetaStore
```

A key-value store scoped to the collection, designed for things like sync tokens and last-modified times. This metadata is persisted between builds alongside the collection data but is only available inside the loader.

```
const lastModified = meta.get("lastModified");
// ...
meta.set("lastModified", new Date().toISOString());
```

```
const lastModified = meta.get("lastModified");
// ...
meta.set("lastModified", new Date().toISOString());
```

#### logger

```
logger
```

Type: AstroIntegrationLogger

```
AstroIntegrationLogger
```

A logger that can be used to log messages to the console. Use this instead of console.log for more helpful logs that include the loader name in the log message. See AstroIntegrationLogger for more information.

```
console.log
```

```
AstroIntegrationLogger
```

#### config

```
config
```

Type: AstroConfig

```
AstroConfig
```

The full, resolved Astro configuration object with all defaults applied. See the configuration reference for more information.

#### parseData

```
parseData
```

Type: (props: ParseDataOptions<TData>) => Promise<TData>

```
(props: ParseDataOptions<TData>) => Promise<TData>
```

Validates and parses the data according to the collection schema. Pass data to this function to validate and parse it before storing it in the data store.

```
import type { Loader } from "astro/loaders";
import { loadFeed } from "./feed.js";


export function feedLoader({ url }): Loader {
  const feedUrl = new URL(url);
  return {
    name: "feed-loader",
    load: async ({ store, logger, parseData, meta, generateDigest }) => {
      logger.info("Loading posts");
      const feed = loadFeed(feedUrl);
      store.clear();


      for (const item of feed.items) {
        const data = await parseData({
          id: item.guid,
          data: item,
        });
        store.set({
          id,
          data,
        });
      }
    },
  };
}
```

```
import type { Loader } from "astro/loaders";
import { loadFeed } from "./feed.js";


export function feedLoader({ url }): Loader {
  const feedUrl = new URL(url);
  return {
    name: "feed-loader",
    load: async ({ store, logger, parseData, meta, generateDigest }) => {
      logger.info("Loading posts");
      const feed = loadFeed(feedUrl);
      store.clear();


      for (const item of feed.items) {
        const data = await parseData({
          id: item.guid,
          data: item,
        });
        store.set({
          id,
          data,
        });
      }
    },
  };
}
```

#### renderMarkdown

```
renderMarkdown
```

Type: (markdown: string) => Promise<RenderedContent>

```
(markdown: string) => Promise<RenderedContent>
```

```
astro@5.9.0
```

Renders a Markdown string to HTML, returning a RenderedContent object.

```
RenderedContent
```

This allows you to render Markdown content directly within your loaders using the same Markdown processing as Astro’s built-in glob loader and provides access to the render() function and <Content /> component for rendering body content.

```
glob
```

```
render()
```

```
<Content />
```

Assign this object to the rendered field of the DataEntry object to allow users to render the content in a page.

```
import type { Loader } from 'astro/loaders';
import { loadFromCMS } from './cms.js';


export function myLoader(settings): Loader {
  return {
    name: 'cms-loader',
    async load({ renderMarkdown, store }) {
      const entries = await loadFromCMS();


      store.clear();


      for (const entry of entries) {
        store.set({
          id: entry.id,
          data: entry,
          // Assume each entry has a 'content' field with markdown content
          rendered: await renderMarkdown(entry.content),
        });
      }
    },
  };
}
```

```
import type { Loader } from 'astro/loaders';
import { loadFromCMS } from './cms.js';


export function myLoader(settings): Loader {
  return {
    name: 'cms-loader',
    async load({ renderMarkdown, store }) {
      const entries = await loadFromCMS();


      store.clear();


      for (const entry of entries) {
        store.set({
          id: entry.id,
          data: entry,
          // Assume each entry has a 'content' field with markdown content
          rendered: await renderMarkdown(entry.content),
        });
      }
    },
  };
}
```

#### generateDigest

```
generateDigest
```

Type: (data: Record<string, unknown> | string) => string

```
(data: Record<string, unknown> | string) => string
```

Generates a non-cryptographic content digest of an object or string. This can be used to track if the data has changed by setting the digest field of an entry.

```
digest
```

```
import type { Loader } from "astro/loaders";
import { loadFeed } from "./feed.js";


export function feedLoader({ url }): Loader {
  const feedUrl = new URL(url);
  return {
    name: "feed-loader",
    load: async ({ store, logger, parseData, meta, generateDigest }) => {
      logger.info("Loading posts");
      const feed = loadFeed(feedUrl);
      store.clear();


      for (const item of feed.items) {
        const data = await parseData({
          id: item.guid,
          data: item,
        });


        const digest = generateDigest(data);


        store.set({
          id,
          data,
          digest,
        });
      }
    },
  };
}
```

```
import type { Loader } from "astro/loaders";
import { loadFeed } from "./feed.js";


export function feedLoader({ url }): Loader {
  const feedUrl = new URL(url);
  return {
    name: "feed-loader",
    load: async ({ store, logger, parseData, meta, generateDigest }) => {
      logger.info("Loading posts");
      const feed = loadFeed(feedUrl);
      store.clear();


      for (const item of feed.items) {
        const data = await parseData({
          id: item.guid,
          data: item,
        });


        const digest = generateDigest(data);


        store.set({
          id,
          data,
          digest,
        });
      }
    },
  };
}
```

#### watcher

```
watcher
```

Type: FSWatcher

```
FSWatcher
```

When running in dev mode, this is a filesystem watcher that can be used to trigger updates. See ViteDevServer for more information.

```
ViteDevServer
```

```
return {
  name: 'file-loader',
  load: async ({ config, store, watcher }) => {
    const url = new URL(fileName, config.root);
    const filePath = fileURLToPath(url);
    await syncData(filePath, store);


    watcher?.on('change', async (changedPath) => {
      if (changedPath === filePath) {
        logger.info(`Reloading data from ${fileName}`);
        await syncData(filePath, store);
      }
    });
  },
};
```

```
return {
  name: 'file-loader',
  load: async ({ config, store, watcher }) => {
    const url = new URL(fileName, config.root);
    const filePath = fileURLToPath(url);
    await syncData(filePath, store);


    watcher?.on('change', async (changedPath) => {
      if (changedPath === filePath) {
        logger.info(`Reloading data from ${fileName}`);
        await syncData(filePath, store);
      }
    });
  },
};
```

#### refreshContextData

```
refreshContextData
```

Type: Record<string, unknown>

```
Record<string, unknown>
```

If the loader has been triggered by an integration, this may optionally contain extra data set by that integration. It is only set when the loader is triggered by an integration. See the astro:server:setup hook reference for more information.

```
astro:server:setup
```

```
export function myLoader(options: { url: string }): Loader {
  return {
    name: "my-loader",
    load: async ({ refreshContextData, store, logger }) => {
      if(refreshContextData?.webhookBody) {
        logger.info("Webhook triggered with body");
        processWebhook(store, refreshContextData.webhookBody);
      }
      // ...
    },
  };
}
```

```
export function myLoader(options: { url: string }): Loader {
  return {
    name: "my-loader",
    load: async ({ refreshContextData, store, logger }) => {
      if(refreshContextData?.webhookBody) {
        logger.info("Webhook triggered with body");
        processWebhook(store, refreshContextData.webhookBody);
      }
      // ...
    },
  };
}
```

### DataStore

```
DataStore
```

The data store is a loader’s interface to the content collection data. It is a key-value (KV) store, scoped to the collection, and therefore a loader can only access the data for its own collection.

#### get

```
get
```

Type: (key: string) => DataEntry | undefined

```
(key: string) => DataEntry | undefined
```

Get an entry from the store by its ID. Returns undefined if the entry does not exist.

```
undefined
```

```
const existingEntry = store.get("my-entry");
```

```
const existingEntry = store.get("my-entry");
```

The returned object is a DataEntry object.

```
DataEntry
```

#### set

```
set
```

Type: (entry: DataEntry) => boolean

```
(entry: DataEntry) => boolean
```

Used after data has been validated and parsed to add an entry to the store, returning true if the entry was set. This returns false when the digest property determines that an entry has not changed and should not be updated.

```
true
```

```
false
```

```
digest
```

```
for (const item of feed.items) {
      const data = await parseData({
        id: item.guid,
        data: item,
      });
      const digest = generateDigest(data);
      store.set({
        id,
        data,
        rendered: {
          html: data.description ?? "",
        },
        digest,
      });
    }
```

```
for (const item of feed.items) {
      const data = await parseData({
        id: item.guid,
        data: item,
      });
      const digest = generateDigest(data);
      store.set({
        id,
        data,
        rendered: {
          html: data.description ?? "",
        },
        digest,
      });
    }
```

#### entries

```
entries
```

Type: () => Array<[id: string, DataEntry]>

```
() => Array<[id: string, DataEntry]>
```

Get all entries in the collection as an array of key-value pairs.

#### keys

```
keys
```

Type: () => Array<string>

```
() => Array<string>
```

Get all the keys of the entries in the collection.

#### values

```
values
```

Type: () => Array<DataEntry>

```
() => Array<DataEntry>
```

Get all entries in the collection as an array.

#### delete

```
delete
```

Type: (key: string) => void

```
(key: string) => void
```

Delete an entry from the store by its ID.

#### clear

```
clear
```

Type: () => void

```
() => void
```

Clear all entries from the collection.

#### has

```
has
```

Type: (key: string) => boolean

```
(key: string) => boolean
```

Check if an entry exists in the store by its ID.

### DataEntry

```
DataEntry
```

This is the type of the object that is stored in the data store. It has the following properties:

#### id

```
id
```

Type: string

```
string
```

An identifier for the entry, which must be unique within the collection. This is used to look up the entry in the store and is the key used with getEntry for that collection.

```
getEntry
```

#### data

```
data
```

Type: Record<string, unknown>

```
Record<string, unknown>
```

The actual data for the entry. When a user accesses the collection, this will have TypeScript types generated according to the collection schema.

It is the loader’s responsibility to use parseData to validate and parse the data before storing it in the data store: no validation is done when getting or setting the data.

```
parseData
```

#### filePath

```
filePath
```

Type: string | undefined

```
string | undefined
```

A path to the file that is the source of this entry, relative to the root of the site. This only applies to file-based loaders and is used to resolve paths such as images or other assets.

If not set, then any fields in the schema that use the image() helper will be treated as public paths and not transformed.

```
image()
```

#### body

```
body
```

Type: string | undefined

```
string | undefined
```

The raw body of the entry, if applicable. If the entry includes rendered content, then this field can be used to store the raw source. This is optional and is not used internally.

#### digest

```
digest
```

Type: string | undefined

```
string | undefined
```

An optional content digest for the entry. This can be used to check if the data has changed.

When setting an entry, the entry will only update if the digest does not match an existing entry with the same ID.

The format of the digest is up to the loader, but it must be a string that changes when the data changes. This can be done with the generateDigest function.

```
generateDigest
```

#### rendered

```
rendered
```

Type: RenderedContent | undefined

```
RenderedContent | undefined
```

Stores an object with an entry’s rendered content and metadata if it has been rendered to HTML. For example, this can be used to store the rendered content of a Markdown entry, or HTML from a CMS.

If this field is provided, then the render() function and <Content /> component are available to render the entry in a page.

```
render()
```

```
<Content />
```

The format of the RenderedContent object is:

```
RenderedContent
```

```
{
  /** Rendered HTML string. If present then `render(entry)` will return a component that renders this HTML. */
  html: string;
  metadata?: {
    /** Any images that are present in this entry. Relative to the DataEntry filePath. */
    imagePaths?: Array<string>;
    /** Any headings that are present in this file. Returned as `headings` from `render()` */
    headings?: MarkdownHeading[];
    /** Raw frontmatter, parsed from the file. This may include data from remark plugins. */
    frontmatter?: Record<string, any>;
    /** Any other metadata that is present in this file. */
    [key: string]: unknown;
  };
}
```

```
{
  /** Rendered HTML string. If present then `render(entry)` will return a component that renders this HTML. */
  html: string;
  metadata?: {
    /** Any images that are present in this entry. Relative to the DataEntry filePath. */
    imagePaths?: Array<string>;
    /** Any headings that are present in this file. Returned as `headings` from `render()` */
    headings?: MarkdownHeading[];
    /** Raw frontmatter, parsed from the file. This may include data from remark plugins. */
    frontmatter?: Record<string, any>;
    /** Any other metadata that is present in this file. */
    [key: string]: unknown;
  };
}
```

If the entry has Markdown content then you can use the renderMarkdown() function to generate this object from the Markdown string.

```
renderMarkdown()
```

## Learn Astro with Coding in Public

150+ video lessons
			
			•
			Astro v5 ready

