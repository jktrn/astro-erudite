- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
								
							
							
	



						
						
	
				
						Pages
						
					
			
				
						Routing
						
					
			
				
						Endpoints
						
					
			
				
						Middleware
						
					
			
				
						Internationalization (i18n)
						
					
			
				
						Prefetch
						
					
			
				
						View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
								
							
							
	



						
						
	
				
						Components
						
					
			
				
						Layouts
						
					
			
				
						Styles and CSS
						
					
			
				
						Fonts
						
					
			
				
						Syntax Highlighting
						
					
			
				
						Scripts and event handling
						
					
			
				
						Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
								
							
							
	



						
						
	
				
						Markdown
						
					
			
				
						Content collections
						
					
			
				
						Images
						
					
			
				
						Data fetching
						
					
			
				
						Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
								
							
							
	



						
						
	
				
						On-demand rendering
						
					
			
				
						Server islands
						
					
			
				
						Actions
						
					
			
				
						Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
								
							
							
	



						
						
	
				
						Upgrade Astro
						
					
			
				
						
						
							
								Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- Upgrade Astro
- Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- v5.0
- v4.0
- v3.0
- v2.0
- v1.0
- Troubleshooting
- How-to recipes
								
							
							
	



						
						
	
				
						Recipes overview
						
					
			
				
						Installing a Vite or Rollup plugin
						
					
			
				
						Analyze bundle size
						
					
			
				
						Build a custom image component
						
					
			
				
						Build HTML forms in Astro pages
						
					
			
				
						Build forms with API routes
						
					
			
				
						Use Bun with Astro
						
					
			
				
						Call endpoints from the server
						
					
			
				
						Verify a Captcha
						
					
			
				
						Customize file names in the build output
						
					
			
				
						Build your Astro site with Docker
						
					
			
				
						Dynamically import images
						
					
			
				
						Add icons to external links
						
					
			
				
						Add i18n features
						
					
			
				
						Create a dev toolbar app
						
					
			
				
						Add last modified time
						
					
			
				
						Add reading time
						
					
			
				
						Add an RSS feed
						
					
			
				
						Share state between Astro components
						
					
			
				
						Share state between islands
						
					
			
				
						Using streaming to improve page performance
						
					
			
				
						Style rendered Markdown with Tailwind Typography
- Recipes overview
- Installing a Vite or Rollup plugin
- Analyze bundle size
- Build a custom image component
- Build HTML forms in Astro pages
- Build forms with API routes
- Use Bun with Astro
- Call endpoints from the server
- Verify a Captcha
- Customize file names in the build output
- Build your Astro site with Docker
- Dynamically import images
- Add icons to external links
- Add i18n features
- Create a dev toolbar app
- Add last modified time
- Add reading time
- Add an RSS feed
- Share state between Astro components
- Share state between islands
- Using streaming to improve page performance
- Style rendered Markdown with Tailwind Typography
- Contribute to Astro
- Astro Template Syntax
Template expressions reference
Template directives reference
- Template expressions reference
- Template directives reference
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
Render context
astro:actions
astro:assets
astro:config
astro:content
astro:env
astro:i18n
astro:middleware
astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
Integration API
Adapter API
Content Loader API
Image Service API
Dev Toolbar App API
Container API (experimental)
Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
Configuring experimental flags
Content Security Policy
Fonts
Live content collections
Client prerendering
Intellisense for collections
Preserve scripts order
Markdown heading ID compatibility
Private meta environment variables inlining
Chrome DevTools workspace
Prerender conflict error
SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- Rules
- Common Directives
				
				
	
				
					class:list
				
				
			
				
					set:html
				
				
			
				
					set:text
- class:list
- set:html
- set:text
- Client Directives
				
				
	
				
					client:load
				
				
			
				
					client:idle
				
				
			
				
					client:visible
				
				
			
				
					client:media
				
				
			
				
					client:only
				
				
			
				
					Custom Client Directives
- client:load
- client:idle
- client:visible
- client:media
- client:only
- Custom Client Directives
- Server Directives
				
				
	
				
					server:defer
- server:defer
- Script & Style Directives
				
				
	
				
					is:global
				
				
			
				
					is:inline
				
				
			
				
					define:vars
- is:global
- is:inline
- define:vars
- Advanced Directives
				
				
	
				
					is:raw
- is:raw
## On this page

- Overview
- Rules
- Common Directives
class:list
set:html
set:text
- class:list
- set:html
- set:text
- Client Directives
client:load
client:idle
client:visible
client:media
client:only
Custom Client Directives
- client:load
- client:idle
- client:visible
- client:media
- client:only
- Custom Client Directives
- Server Directives
server:defer
- server:defer
- Script & Style Directives
is:global
is:inline
define:vars
- is:global
- is:inline
- define:vars
- Advanced Directives
is:raw
- is:raw
## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

# Template directives reference

Template directives are a special kind of HTML attribute available inside of any Astro component template (.astro files), and some can also be used in .mdx files.

```
.astro
```

```
.mdx
```

Template directives are used to control an element or component’s behavior in some way. A template directive could enable some compiler feature that makes your life easier (like using class:list instead of class). Or, a directive could tell the Astro compiler to do something special with that component (like hydrating with client:load).

```
class:list
```

```
class
```

```
client:load
```

This page describes all of the template directives available to you in Astro, and how they work.

## Rules

For a template directive to be valid, it must:

- Include a colon : in its name, using the form X:Y (ex: client:load).
```
:
```

```
X:Y
```

```
client:load
```

- Be visible to the compiler (ex: <X {...attr}> would not work if attr contained a directive).
```
<X {...attr}>
```

```
attr
```

Some template directives, but not all, can take a custom value:

- <X client:load /> (takes no value)
```
<X client:load />
```

- <X class:list={['some-css-class']} /> (takes an array)
```
<X class:list={['some-css-class']} />
```

A template directive is never included directly in the final HTML output of a component.

## Common Directives

### class:list

```
class:list
```

class:list={...} takes an array of class values and converts them into a class string. This is powered by @lukeed’s popular clsx helper library.

```
class:list={...}
```

class:list takes an array of several different possible value kinds:

```
class:list
```

- string: Added to the element class
```
string
```

```
class
```

- Object: All truthy keys are added to the element class
```
Object
```

```
class
```

- Array: flattened
```
Array
```

- false, null, or undefined: skipped
```
false
```

```
null
```

```
undefined
```

```
<!-- This -->
<span class:list={[ 'hello goodbye', { world: true }, [ 'friend' ] ]} />
<!-- Becomes -->
<span class="hello goodbye world friend"></span>
```

```
<!-- This -->
<span class:list={[ 'hello goodbye', { world: true }, [ 'friend' ] ]} />
<!-- Becomes -->
<span class="hello goodbye world friend"></span>
```

### set:html

```
set:html
```

set:html={string} injects an HTML string into an element, similar to setting el.innerHTML.

```
set:html={string}
```

```
el.innerHTML
```

The value is not automatically escaped by Astro! Be sure that you trust the value, or that you have escaped it manually before passing it to the template. Forgetting to do this will open you up to Cross Site Scripting (XSS) attacks.

```
---
const rawHTMLString = "Hello <strong>World</strong>"
---
<h1>{rawHTMLString}</h1>
  <!-- Output: <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->
<h1 set:html={rawHTMLString} />
  <!-- Output: <h1>Hello <strong>World</strong></h1> -->
```

```
---
const rawHTMLString = "Hello <strong>World</strong>"
---
<h1>{rawHTMLString}</h1>
  <!-- Output: <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->
<h1 set:html={rawHTMLString} />
  <!-- Output: <h1>Hello <strong>World</strong></h1> -->
```

You can also use set:html on a <Fragment> to avoid adding an unnecessary wrapper element. This can be especially useful when fetching HTML from a CMS.

```
set:html
```

```
<Fragment>
```

```
---
const cmsContent = await fetchHTMLFromMyCMS();
---
<Fragment set:html={cmsContent}>
```

```
---
const cmsContent = await fetchHTMLFromMyCMS();
---
<Fragment set:html={cmsContent}>
```

set:html={Promise<string>} injects an HTML string into an element that is wrapped in a Promise.

```
set:html={Promise<string>}
```

This can be used to inject HTML stored externally, such as in a database.

```
---
import api from '../db/api.js';
---
<article set:html={api.getArticle(Astro.props.id)}></article>
```

```
---
import api from '../db/api.js';
---
<article set:html={api.getArticle(Astro.props.id)}></article>
```

set:html={Promise<Response>} injects a Response into an element.

```
set:html={Promise<Response>}
```

This is most helpful when using fetch(). For example, fetching old posts from a previous static-site generator.

```
fetch()
```

```
<article set:html={fetch('http://example/old-posts/making-soup.html')}></article>
```

```
<article set:html={fetch('http://example/old-posts/making-soup.html')}></article>
```

set:html can be used on any tag and does not have to include HTML. For example, use with JSON.stringify() on a <script> tag to add a JSON-LD schema to your page.

```
set:html
```

```
JSON.stringify()
```

```
<script>
```

```
<script type="application/ld+json" set:html={JSON.stringify({
  "@context": "https://schema.org/",
  "@type": "Person",
  name: "Houston",
  hasOccupation: {
    "@type": "Occupation",
    name: "Astronaut"
  }
})}/>
```

```
<script type="application/ld+json" set:html={JSON.stringify({
  "@context": "https://schema.org/",
  "@type": "Person",
  name: "Houston",
  hasOccupation: {
    "@type": "Occupation",
    name: "Astronaut"
  }
})}/>
```

### set:text

```
set:text
```

set:text={string} injects a text string into an element, similar to setting el.innerText. Unlike set:html, the string value that is passed is automatically escaped by Astro.

```
set:text={string}
```

```
el.innerText
```

```
set:html
```

```
string
```

This is equivalent to just passing a variable into a template expression directly (ex: <div>{someText}</div>) and therefore this directive is not commonly used.

```
<div>{someText}</div>
```

## Client Directives

These directives control how UI Framework components are hydrated on the page.

By default, a UI Framework component is not hydrated in the client. If no client:* directive is provided, its HTML is rendered onto the page without JavaScript.

```
client:*
```

A client directive can only be used on a UI framework component that is directly imported into a .astro component. Hydration directives are not supported when using dynamic tags and custom components passed via the components prop.

```
.astro
```

```
components
```

### client:load

```
client:load
```

- Priority: High
- Useful for: Immediately-visible UI elements that need to be interactive as soon as possible.
Load and hydrate the component JavaScript immediately on page load.

```
<BuyButton client:load />
```

```
<BuyButton client:load />
```

### client:idle

```
client:idle
```

- Priority: Medium
- Useful for: Lower-priority UI elements that don’t need to be immediately interactive.
Load and hydrate the component JavaScript once the page is done with its initial load and the requestIdleCallback event has fired. If you are in a browser that doesn’t support requestIdleCallback, then the document load event is used.

```
requestIdleCallback
```

```
requestIdleCallback
```

```
load
```

```
<ShowHideButton client:idle />
```

```
<ShowHideButton client:idle />
```

#### timeout

```
timeout
```

Added in: astro@4.15.0

```
astro@4.15.0
```

The maximum time to wait, in milliseconds, before hydrating the component, even if the page is not yet done with its initial load.

This allows you to pass a value for the timeout option from the requestIdleCallback() specification. This means you can delay hydration for lower-priority UI elements with more control to ensure your element is interactive within a specified time frame.

```
timeout
```

```
requestIdleCallback()
```

```
<ShowHideButton client:idle={{timeout: 500}} />
```

```
<ShowHideButton client:idle={{timeout: 500}} />
```

### client:visible

```
client:visible
```

- Priority: Low
- Useful for: Low-priority UI elements that are either far down the page (“below the fold”) or so resource-intensive to load that you would prefer not to load them at all if the user never saw the element.
Load and hydrate the component JavaScript once the component has entered the user’s viewport. This uses an IntersectionObserver internally to keep track of visibility.

```
IntersectionObserver
```

```
<HeavyImageCarousel client:visible />
```

```
<HeavyImageCarousel client:visible />
```

#### client:visible={{rootMargin}}

```
client:visible={{rootMargin}}
```

Added in: astro@4.1.0

```
astro@4.1.0
```

Optionally, a value for rootMargin can be passed to the underlying IntersectionObserver. When rootMargin is specified, the component JavaScript will hydrate when a specified margin (in pixels) around the component enters the viewport, rather than the component itself.

```
rootMargin
```

```
IntersectionObserver
```

```
rootMargin
```

```
<HeavyImageCarousel client:visible={{rootMargin: "200px"}} />
```

```
<HeavyImageCarousel client:visible={{rootMargin: "200px"}} />
```

Specifying a rootMargin value can reduce layout shifts (CLS), allow more time for a component to hydrate on slower internet connections, and make components interactive sooner, enhancing the stability and responsiveness of the page.

```
rootMargin
```

### client:media

```
client:media
```

- Priority: Low
- Useful for: Sidebar toggles, or other elements that might only be visible on certain screen sizes.
client:media={string} loads and hydrates the component JavaScript once a certain CSS media query is met.

```
client:media={string}
```

Note

If the component is already hidden and shown by a media query in your CSS, then it can be easier to just use client:visible and not pass that same media query into the directive.

```
client:visible
```

```
<SidebarToggle client:media="(max-width: 50em)" />
```

```
<SidebarToggle client:media="(max-width: 50em)" />
```

### client:only

```
client:only
```

client:only={string} skips HTML server rendering, and renders only on the client. It acts similarly to client:load in that it loads, renders, and hydrates the component immediately on page load.

```
client:only={string}
```

```
client:load
```

You must pass the component’s correct framework as a value! Because Astro doesn’t run the component during your build / on the server, Astro doesn’t know what framework your component uses unless you tell it explicitly.

```
<SomeReactComponent client:only="react" />
<SomePreactComponent client:only="preact" />
<SomeSvelteComponent client:only="svelte" />
<SomeVueComponent client:only="vue" />
<SomeSolidComponent client:only="solid-js" />
```

```
<SomeReactComponent client:only="react" />
<SomePreactComponent client:only="preact" />
<SomeSvelteComponent client:only="svelte" />
<SomeVueComponent client:only="vue" />
<SomeSolidComponent client:only="solid-js" />
```

#### Display loading content

For components that render only on the client, it is also possible to display fallback content while they are loading. Use slot="fallback" on any child element to create content that will be displayed only until your client component is available:

```
slot="fallback"
```

```
<ClientComponent client:only="vue">
  <div slot="fallback">Loading</div>
</ClientComponent>
```

```
<ClientComponent client:only="vue">
  <div slot="fallback">Loading</div>
</ClientComponent>
```

### Custom Client Directives

Since Astro 2.6.0, integrations can also add custom client:* directives to change how and when components should be hydrated.

```
client:*
```

Visit the addClientDirective API page to learn more about creating a custom client directive.

```
addClientDirective
```

## Server Directives

These directives control how server island components are rendered.

### server:defer

```
server:defer
```

The server:defer directive transforms the component into a server island, causing it to be rendered on demand, outside the scope of the rest of the page rendering.

```
server:defer
```

```
<Avatar server:defer />
```

```
<Avatar server:defer />
```

## Script & Style Directives

These directives can only be used on HTML <script> and <style> tags, to control how your client-side JavaScript and CSS are handled on the page.

```
<script>
```

```
<style>
```

### is:global

```
is:global
```

By default, Astro automatically scopes <style> CSS rules to the component. You can opt-out of this behavior with the is:global directive.

```
<style>
```

```
is:global
```

is:global makes the contents of a <style> tag apply globally on the page when the component is included. This disables Astro’s CSS scoping system. This is equivalent to wrapping all of the selectors within a <style> tag with :global().

```
is:global
```

```
<style>
```

```
<style>
```

```
:global()
```

You can combine <style> and <style is:global> together in the same component, to create some global style rules while still scoping most of your component CSS.

```
<style>
```

```
<style is:global>
```

```
<style is:global>
  body a { color: red; }
</style>
```

```
<style is:global>
  body a { color: red; }
</style>
```

### is:inline

```
is:inline
```

By default, Astro will process, optimize, and bundle any <script> and <style> tags that it sees on the page. You can opt-out of this behavior with the is:inline directive.

```
<script>
```

```
<style>
```

```
is:inline
```

is:inline tells Astro to leave the <script> or <style> tag as-is in the final output HTML. The contents will not be processed, optimized, or bundled. This limits some Astro features, like importing an npm package or using a compile-to-CSS language like Sass.

```
is:inline
```

```
<script>
```

```
<style>
```

The is:inline directive means that <style> and <script> tags:

```
is:inline
```

```
<style>
```

```
<script>
```

- Will not be bundled into an external file. This means that attributes like defer which control the loading of an external file will have no effect.
```
defer
```

- Will not be deduplicated—the element will appear as many times as it is rendered.
- Will not have its import/@import/url() references resolved relative to the .astro file.
```
import
```

```
@import
```

```
url()
```

```
.astro
```

- Will be rendered in the final output HTML exactly where it is authored.
- Styles will be global and not scoped to the component.
Caution

The is:inline directive is implied whenever any attribute other than src is used on a <script> or <style> tag. The one exception is using the define:vars directive on the <style> tag, which does not automatically imply is:inline.

```
is:inline
```

```
src
```

```
<script>
```

```
<style>
```

```
define:vars
```

```
<style>
```

```
is:inline
```

```
<style is:inline>
  /* inline: relative & npm package imports are not supported. */
  @import '/assets/some-public-styles.css';
  span { color: green; }
</style>


<script is:inline>
  /* inline: relative & npm package imports are not supported. */
  console.log('I am inlined right here in the final output HTML.');
</script>
```

```
<style is:inline>
  /* inline: relative & npm package imports are not supported. */
  @import '/assets/some-public-styles.css';
  span { color: green; }
</style>


<script is:inline>
  /* inline: relative & npm package imports are not supported. */
  console.log('I am inlined right here in the final output HTML.');
</script>
```

### define:vars

```
define:vars
```

define:vars={...} can pass server-side variables from your component frontmatter into the client <script> or <style> tags. Any JSON-serializable frontmatter variable is supported, including props passed to your component through Astro.props. Values are serialized with JSON.stringify().

```
define:vars={...}
```

```
<script>
```

```
<style>
```

```
props
```

```
Astro.props
```

```
JSON.stringify()
```

```
---
const foregroundColor = "rgb(221 243 228)";
const backgroundColor = "rgb(24 121 78)";
const message = "Astro is awesome!";
---
<style define:vars={{ textColor: foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--textColor);
  }
</style>


<script define:vars={{ message }}>
  alert(message);
</script>
```

```
---
const foregroundColor = "rgb(221 243 228)";
const backgroundColor = "rgb(24 121 78)";
const message = "Astro is awesome!";
---
<style define:vars={{ textColor: foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--textColor);
  }
</style>


<script define:vars={{ message }}>
  alert(message);
</script>
```

Caution

Using define:vars on a <script> tag implies the is:inline directive, which means your scripts won’t be bundled and will be inlined directly into the HTML.

```
define:vars
```

```
<script>
```

```
is:inline
```

This is because when Astro bundles a script, it includes and runs the script once even if you include the component containing the script multiple times on one page. define:vars requires a script to rerun with each set of values, so Astro creates an inline script instead.

```
define:vars
```

For scripts, try passing variables to scripts manually instead.

## Advanced Directives

### is:raw

```
is:raw
```

is:raw instructs the Astro compiler to treat any children of that element as text. This means that all special Astro templating syntax will be ignored inside of this component.

```
is:raw
```

For example, if you had a custom Katex component that converted some text to HTML, you could have users do this:

```
---
import Katex from '../components/Katex.astro';
---
<Katex is:raw>Some conflicting {syntax} here</Katex>
```

```
---
import Katex from '../components/Katex.astro';
---
<Katex is:raw>Some conflicting {syntax} here</Katex>
```

## Learn Astro with Coding in Public

150+ video lessons
			
			•
			Astro v5 ready

