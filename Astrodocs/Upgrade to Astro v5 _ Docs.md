- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
Pages
Routing
Endpoints
Middleware
Internationalization (i18n)
Prefetch
View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
Components
Layouts
Styles and CSS
Fonts
Syntax Highlighting
Scripts and event handling
Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
Markdown
Content collections
Images
Data fetching
Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
On-demand rendering
Server islands
Actions
Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
Upgrade Astro
Major upgrade guides
v5.0
v4.0
v3.0
v2.0
v1.0
- Upgrade Astro
- Major upgrade guides
v5.0
v4.0
v3.0
v2.0
v1.0
- v5.0
- v4.0
- v3.0
- v2.0
- v1.0
- Troubleshooting
- How-to recipes
- Contribute to Astro
- Astro Template Syntax
								
							
							
	



						
						
	
				
						Template expressions reference
						
					
			
				
						Template directives reference
- Template expressions reference
- Template directives reference
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
								
							
							
	



						
						
	
				
						Render context
						
					
			
				
						astro:actions
						
					
			
				
						astro:assets
						
					
			
				
						astro:config
						
					
			
				
						astro:content
						
					
			
				
						astro:env
						
					
			
				
						astro:i18n
						
					
			
				
						astro:middleware
						
					
			
				
						astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
								
							
							
	



						
						
	
				
						Integration API
						
					
			
				
						Adapter API
						
					
			
				
						Content Loader API
						
					
			
				
						Image Service API
						
					
			
				
						Dev Toolbar App API
						
					
			
				
						Container API (experimental)
						
					
			
				
						Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
								
							
							
	



						
						
	
				
						Configuring experimental flags
						
					
			
				
						Content Security Policy
						
					
			
				
						Fonts
						
					
			
				
						Live content collections
						
					
			
				
						Client prerendering
						
					
			
				
						Intellisense for collections
						
					
			
				
						Preserve scripts order
						
					
			
				
						Markdown heading ID compatibility
						
					
			
				
						Private meta environment variables inlining
						
					
			
				
						Chrome DevTools workspace
						
					
			
				
						Prerender conflict error
						
					
			
				
						SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- Upgrade Astro
- Dependency Upgrades
				
				
	
				
					Vite 6.0
				
				
			
				
					@astrojs/mdx
- Vite 6.0
- @astrojs/mdx
- Legacy
				
				
	
				
					Legacy: v2.0 Content Collections API
- Legacy: v2.0 Content Collections API
- Deprecated
				
				
	
				
					Deprecated: Astro.glob()
				
				
			
				
					Deprecated: functionPerRoute (Adapter API)
				
				
			
				
					Deprecated: routes on astro:build:done hook (Integration API)
- Deprecated: Astro.glob()
- Deprecated: functionPerRoute (Adapter API)
- Deprecated: routes on astro:build:done hook (Integration API)
- Removed
				
				
	
				
					Removed: The Lit integration
				
				
			
				
					Removed: hybrid rendering mode
				
				
			
				
					Removed: support for dynamic prerender values in routes
				
				
			
				
					Removed: Squoosh image service
				
				
			
				
					Removed: some public-facing types
				
				
			
				
					Experimental Flags
- Removed: The Lit integration
- Removed: hybrid rendering mode
- Removed: support for dynamic prerender values in routes
- Removed: Squoosh image service
- Removed: some public-facing types
- Experimental Flags
- Changed Defaults
				
				
	
				
					CSRF protection is now set by default
				
				
			
				
					Route priority order for injected routes and redirects
				
				
			
				
					<script> tags are rendered directly as declared
- CSRF protection is now set by default
- Route priority order for injected routes and redirects
- <script> tags are rendered directly as declared
- Breaking Changes
				
				
	
				
					Renamed: <ViewTransitions /> component
				
				
			
				
					Changed: TypeScript configuration
				
				
			
				
					Changed: Actions submitted by HTML forms no longer use cookie redirects
				
				
			
				
					Changed: compiledContent() is now an async function
				
				
			
				
					Changed: astro:content can no longer be used on the client
				
				
			
				
					Renamed: Shiki css-variables theme color token names
				
				
			
				
					Changed: internal Shiki rehype plugin for highlighting code blocks
				
				
			
				
					Changed: Automatic charset=utf-8 behavior for Markdown and MDX pages
				
				
			
				
					Changed: Astro-specific metadata attached in remark and rehype plugins
				
				
			
				
					Changed: image endpoint configuration
				
				
			
				
					Changed: build.client and build.server resolve behavior
				
				
			
				
					Changed: JS dependencies in config file are no longer processed by Vite
				
				
			
				
					Changed: URLs returned by paginate()
				
				
			
				
					Changed: non-boolean HTML attribute values
				
				
			
				
					Changed: adding values to context.locals
				
				
			
				
					Changed: params no longer decoded
				
				
			
				
					Changed: RouteData type replaced by IntegrationsRouteData (Integrations API)
				
				
			
				
					Changed: distURL is now an array (Integrations API)
				
				
			
				
					Changed: Arguments passed to app.render() (Adapter API)
				
				
			
				
					Changed: Properties on supportedAstroFeatures (Adapter API)
				
				
			
				
					Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)
				
				
			
				
					Removed: configuring Typescript during create-astro
- Renamed: <ViewTransitions /> component
- Changed: TypeScript configuration
- Changed: Actions submitted by HTML forms no longer use cookie redirects
- Changed: compiledContent() is now an async function
- Changed: astro:content can no longer be used on the client
- Renamed: Shiki css-variables theme color token names
- Changed: internal Shiki rehype plugin for highlighting code blocks
- Changed: Automatic charset=utf-8 behavior for Markdown and MDX pages
- Changed: Astro-specific metadata attached in remark and rehype plugins
- Changed: image endpoint configuration
- Changed: build.client and build.server resolve behavior
- Changed: JS dependencies in config file are no longer processed by Vite
- Changed: URLs returned by paginate()
- Changed: non-boolean HTML attribute values
- Changed: adding values to context.locals
- Changed: params no longer decoded
- Changed: RouteData type replaced by IntegrationsRouteData (Integrations API)
- Changed: distURL is now an array (Integrations API)
- Changed: Arguments passed to app.render() (Adapter API)
- Changed: Properties on supportedAstroFeatures (Adapter API)
- Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)
- Removed: configuring Typescript during create-astro
- Community Resources
- Known Issues
## On this page

- Overview
- Upgrade Astro
- Dependency Upgrades
Vite 6.0
@astrojs/mdx
- Vite 6.0
- @astrojs/mdx
- Legacy
Legacy: v2.0 Content Collections API
- Legacy: v2.0 Content Collections API
- Deprecated
Deprecated: Astro.glob()
Deprecated: functionPerRoute (Adapter API)
Deprecated: routes on astro:build:done hook (Integration API)
- Deprecated: Astro.glob()
- Deprecated: functionPerRoute (Adapter API)
- Deprecated: routes on astro:build:done hook (Integration API)
- Removed
Removed: The Lit integration
Removed: hybrid rendering mode
Removed: support for dynamic prerender values in routes
Removed: Squoosh image service
Removed: some public-facing types
Experimental Flags
- Removed: The Lit integration
- Removed: hybrid rendering mode
- Removed: support for dynamic prerender values in routes
- Removed: Squoosh image service
- Removed: some public-facing types
- Experimental Flags
- Changed Defaults
CSRF protection is now set by default
Route priority order for injected routes and redirects
<script> tags are rendered directly as declared
- CSRF protection is now set by default
- Route priority order for injected routes and redirects
- <script> tags are rendered directly as declared
- Breaking Changes
Renamed: <ViewTransitions /> component
Changed: TypeScript configuration
Changed: Actions submitted by HTML forms no longer use cookie redirects
Changed: compiledContent() is now an async function
Changed: astro:content can no longer be used on the client
Renamed: Shiki css-variables theme color token names
Changed: internal Shiki rehype plugin for highlighting code blocks
Changed: Automatic charset=utf-8 behavior for Markdown and MDX pages
Changed: Astro-specific metadata attached in remark and rehype plugins
Changed: image endpoint configuration
Changed: build.client and build.server resolve behavior
Changed: JS dependencies in config file are no longer processed by Vite
Changed: URLs returned by paginate()
Changed: non-boolean HTML attribute values
Changed: adding values to context.locals
Changed: params no longer decoded
Changed: RouteData type replaced by IntegrationsRouteData (Integrations API)
Changed: distURL is now an array (Integrations API)
Changed: Arguments passed to app.render() (Adapter API)
Changed: Properties on supportedAstroFeatures (Adapter API)
Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)
Removed: configuring Typescript during create-astro
- Renamed: <ViewTransitions /> component
- Changed: TypeScript configuration
- Changed: Actions submitted by HTML forms no longer use cookie redirects
- Changed: compiledContent() is now an async function
- Changed: astro:content can no longer be used on the client
- Renamed: Shiki css-variables theme color token names
- Changed: internal Shiki rehype plugin for highlighting code blocks
- Changed: Automatic charset=utf-8 behavior for Markdown and MDX pages
- Changed: Astro-specific metadata attached in remark and rehype plugins
- Changed: image endpoint configuration
- Changed: build.client and build.server resolve behavior
- Changed: JS dependencies in config file are no longer processed by Vite
- Changed: URLs returned by paginate()
- Changed: non-boolean HTML attribute values
- Changed: adding values to context.locals
- Changed: params no longer decoded
- Changed: RouteData type replaced by IntegrationsRouteData (Integrations API)
- Changed: distURL is now an array (Integrations API)
- Changed: Arguments passed to app.render() (Adapter API)
- Changed: Properties on supportedAstroFeatures (Adapter API)
- Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)
- Removed: configuring Typescript during create-astro
- Community Resources
- Known Issues
## Learn Astro with Coding in Public

150+ video lessons
•
Astro v5 ready

# Upgrade to Astro v5

This guide will help you migrate from Astro v4 to Astro v5.

Need to upgrade an older project to v4 first? See our older migration guide.

Need to see the v4 docs? Visit this older version of the docs site (unmaintained v4.16 snapshot).

## Upgrade Astro

Update your project’s version of Astro to the latest version using your package manager:

- npm
- pnpm
- Yarn
```
# Upgrade Astro and official integrations together
npx @astrojs/upgrade
```

```
# Upgrade Astro and official integrations together
npx @astrojs/upgrade
```

```
# Upgrade Astro and official integrations togetherpnpm dlx @astrojs/upgrade
```

```
# Upgrade Astro and official integrations togetherpnpm dlx @astrojs/upgrade
```

```
# Upgrade Astro and official integrations togetheryarn dlx @astrojs/upgrade
```

```
# Upgrade Astro and official integrations togetheryarn dlx @astrojs/upgrade
```

You can also upgrade your Astro integrations manually if needed, and you may also need to upgrade other dependencies in your project.

Need to continue?

After upgrading Astro, you may not need to make any changes to your project at all!

But, if you notice errors or unexpected behavior, please check below for what has changed that might need updating in your project.

Astro v5.0 includes potentially breaking changes, as well as the removal and deprecation of some features.

If your project doesn’t work as expected after upgrading to v5.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase.

See the Astro changelog for full release notes.

## Dependency Upgrades

Any major upgrades to Astro’s dependencies may cause breaking changes in your project.

### Vite 6.0

Astro v5.0 upgrades to Vite v6.0 as the development server and production bundler.

#### What should I do?

If you are using Vite-specific plugins, configuration, or APIs, check the Vite migration guide for their breaking changes and upgrade your project as needed.

### @astrojs/mdx

```
@astrojs/mdx
```

In Astro v4.x, Astro performed internal JSX handling for the @astrojs/mdx integration.

```
@astrojs/mdx
```

Astro v5.0 moves this responsibility to handle and render JSX and MDX to the @astrojs/mdx package directly. This means that Astro 5.0 is no longer compatible with older versions of the MDX integration.

```
@astrojs/mdx
```

#### What should I do?

If your project includes .mdx files, you must upgrade @astrojs/mdx to the latest version (v4.0.0) so that your JSX can be handled properly by the integration.

```
.mdx
```

```
@astrojs/mdx
```

If you are using an MDX server renderer with the experimental Astro Container API you must update the import to reflect the new location:

```
import mdxRenderer from "astro/jsx/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";
```

```
import mdxRenderer from "astro/jsx/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";
```

## Legacy

The following features are now considered legacy features. They should function normally but are no longer recommended and are in maintenance mode. They will see no future improvements and documentation will not be updated. These features will eventually be deprecated, and then removed entirely.

### Legacy: v2.0 Content Collections API

In Astro 4.x, content collections were defined, queried, and rendered using the Content Collections API first introduced in Astro v2.0. All collection entries were local files within the reserved src/content/ folder. Additionally, Astro’s file name convention to exclude building individual pages was built in to the Content Collections API.

```
src/content/
```

Astro 5.0 introduces a new version of content collections using the Content Layer API which brings several performance improvements and added capabilities. While old (legacy) and new (Content Layer API) collections can continue exist together in this release, there are potentially breaking changes to existing legacy collections.

This release also removes the option to prefix collection entry file names with an underscore (_) to prevent building a route.

```
_
```

#### What should I do?

We recommend converting any existing collections to the new Content Layer API as soon as you are able and making any new collections using the Content Layer API.

If you are unable to convert your collections, then please consult the legacy collections breaking changes to see whether your existing collections are affected and require updating.

If you are unable to make any changes to your collections at this time, you can enable the legacy.collections flag which will allow you to keep your collections in their current state until the legacy flag is no longer supported.

```
legacy.collections
```

##### Updating existing collections

See the instructions below for updating an existing content collection (type: 'content' or type: 'data') to use the Content Layer API.

```
type: 'content'
```

```
type: 'data'
```

##### Breaking changes to legacy content and data collections

```
content
```

```
data
```

By default, collections that use the old type property (content or data) and do not define a loader are now implemented under the hood using the Content Layer API’s built-in glob() loader, with extra backward-compatibility handling.

```
type
```

```
content
```

```
data
```

```
loader
```

```
glob()
```

Additionally, temporary backwards compatibility exists for keeping the content config file in its original location of src/content/config.ts.

```
src/content/config.ts
```

This backwards compatibility implementation is able to emulate most of the features of legacy collections and will allow many legacy collections to continue to work even without updating your code. However, there are some differences and limitations that may cause breaking changes to existing collections:

- In previous versions of Astro, collections would be generated for all folders in src/content/, even if they were not defined in src/content/config.ts. This behavior is now deprecated, and collections should always be defined in src/content.config.ts. For existing collections, these can just be empty declarations (e.g. const blog = defineCollection({})) and Astro will implicitly define your legacy collection for you in a way that is compatible with the new loading behavior.
```
src/content/
```

```
src/content/config.ts
```

```
src/content.config.ts
```

```
const blog = defineCollection({})
```

- The special layout field is not supported in Markdown collection entries. This property is intended only for standalone page files located in src/pages/ and not likely to be in your collection entries. However, if you were using this property, you must now create dynamic routes that include your page styling.
```
layout
```

```
src/pages/
```

- Sort order of generated collections is non-deterministic and platform-dependent. This means that if you are calling getCollection(), the order in which entries are returned may be different than before. If you need a specific order, you must sort the collection entries yourself.
```
getCollection()
```

- image().refine() is not supported. If you need to validate the properties of an image you will need to do this at runtime in your page or component.
```
image().refine()
```

- The key argument of getEntry(collection, key) is typed as string, rather than having types for every entry.
```
key
```

```
getEntry(collection, key)
```

```
string
```

- Previously when calling getEntry(collection, key) with a static string as the key, the return type was not nullable. The type now includes undefined so you must check if the entry is defined before using the result or you will have type errors.
```
getEntry(collection, key)
```

```
undefined
```

##### Enabling the legacy.collections flag

```
legacy.collections
```

If you are not yet ready to update your existing collections, you can enable the legacy.collections flag and your existing collections will continue to function as before.

```
legacy.collections
```

## Deprecated

The following deprecated features are no longer supported and are no longer documented. Please update your project accordingly.

Some deprecated features may temporarily continue to function until they are completely removed. Others may silently have no effect, or throw an error prompting you to update your code.

### Deprecated: Astro.glob()

```
Astro.glob()
```

In Astro v4.x, you could use Astro.glob() in your .astro components to query multiple files in your project. This had some limitations (where it could be used, performance, etc.), and using querying functions from the Content Collections API or Vite’s own import.meta.glob() often provided more function and flexibility.

```
Astro.glob()
```

```
.astro
```

```
import.meta.glob()
```

Astro 5.0 deprecates Astro.glob() in favor of using getCollection() to query your collections, and import.meta.glob() to query other source files in your project.

```
Astro.glob()
```

```
getCollection()
```

```
import.meta.glob()
```

#### What should I do?

Replace all use of Astro.glob() with import.meta.glob(). Note that import.meta.glob() no longer returns a Promise, so you may have to update your code accordingly. You should not require any updates to your glob patterns.

```
Astro.glob()
```

```
import.meta.glob()
```

```
import.meta.glob()
```

```
Promise
```

```
---
const posts = await Astro.glob('./posts/*.md');
const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));
---


{posts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
```

```
---
const posts = await Astro.glob('./posts/*.md');
const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));
---


{posts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
```

Where appropriate, consider using content collections to organize your content, which has its own newer, more performant querying functions.

You may also wish to consider using glob packages from NPM, such as fast-glob.

```
fast-glob
```

```
import.meta.glob
```

### Deprecated: functionPerRoute (Adapter API)

```
functionPerRoute
```

In Astro v4.x, you could opt into creating a separate file for each route defined in the project, mirroring your src/pages/ directory in the build folder. By default, Astro emitted a single entry.mjs file, which was responsible for emitting the rendered page on each request.

```
src/pages/
```

```
entry.mjs
```

Astro v5.0 removes the option to opt out of the default behavior. This behavior is now standard, and non-configurable.

Remove the functionPerRoute property from your adapterFeatures configuration. It is no longer available.

```
functionPerRoute
```

```
adapterFeatures
```

```
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
    },
  };
}
```

```
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
    },
  };
}
```

### Deprecated: routes on astro:build:done hook (Integration API)

```
routes
```

```
astro:build:done
```

In Astro v4.x, integrations accessed routes from the astro:build:done hook.

```
astro:build:done
```

Astro v5.0 deprecates the routes array passed to this hook. Instead, it exposes a new astro:routes:resolved hook that runs before astro:config:done, and whenever a route changes in development. It has all the same properties of the deprecated routes list, except distURL which is only available during build.

```
routes
```

```
astro:routes:resolved
```

```
astro:config:done
```

```
routes
```

```
distURL
```

#### What should I do?

Remove any instance of routes passed to astro:build:done and replace it with the new astro:routes:resolved hook. Access distURL on the newly exposed assets map:

```
routes
```

```
astro:build:done
```

```
astro:routes:resolved
```

```
distURL
```

```
assets
```

```
const integration = () => {
    let routes
    return {
        name: 'my-integration',
        hooks: {
            'astro:routes:resolved': (params) => {
                routes = params.routes
            },
            'astro:build:done': ({
                routes
                assets
            }) => {
                for (const route of routes) {
                    const distURL = assets.get(route.pattern)
                    if (distURL) {
                        Object.assign(route, { distURL })
                    }
                }
                console.log(routes)
            }
        }
    }
}
```

```
const integration = () => {
    let routes
    return {
        name: 'my-integration',
        hooks: {
            'astro:routes:resolved': (params) => {
                routes = params.routes
            },
            'astro:build:done': ({
                routes
                assets
            }) => {
                for (const route of routes) {
                    const distURL = assets.get(route.pattern)
                    if (distURL) {
                        Object.assign(route, { distURL })
                    }
                }
                console.log(routes)
            }
        }
    }
}
```

```
astro:routes:resolved
```

## Removed

The following features have now been entirely removed from the code base and can no longer be used. Some of these features may have continued to work in your project even after deprecation. Others may have silently had no effect.

Projects now containing these removed features will be unable to build, and there will no longer be any supporting documentation prompting you to remove these features.

### Removed: The Lit integration

In Astro v4.x, Lit was a core-maintained framework library through the @astrojs/lit package.

```
@astrojs/lit
```

Astro v5.0 removes the integration and it will not receive further updates for compatibility with 5.x and above.

#### What should I do?

You can continue to use Lit for client components by adding a client-side script tag. For example:

```
<script>
  import "../components/MyTabs";
</script>


<my-tabs title="These are my tabs">...</my-tabs>
```

```
<script>
  import "../components/MyTabs";
</script>


<my-tabs title="These are my tabs">...</my-tabs>
```

If you’re interested in maintaining a Lit integration yourself, you may wish to use the last published version of @astrojs/lit as a starting point and upgrade the relevant packages.

```
@astrojs/lit
```

### Removed: hybrid rendering mode

```
hybrid
```

In Astro v4.x, Astro provided three rendering output rendering modes: 'static', 'hybrid', and 'server'

```
output
```

```
'static'
```

```
'hybrid'
```

```
'server'
```

Astro v5.0 merges the output: 'hybrid' and output: 'static' configurations into one single configuration (now called 'static') that works the same way as the previous hybrid option.

```
output: 'hybrid'
```

```
output: 'static'
```

```
'static'
```

It is no longer necessary to specify output: 'hybrid' in your Astro config to use server-rendered pages. The new output: 'static' has this capability included.

```
output: 'hybrid'
```

```
output: 'static'
```

Astro will now automatically allow you to opt out of prerendering in your static site with no change to your output configuration required. Any page route or endpoint can include export const prerender = false to be server-rendered on demand, while the rest of your site is statically generated.

```
export const prerender = false
```

#### What should I do?

If your project used hybrid rendering, you must now remove the output: 'hybrid' option from your Astro config as it no longer exists. However, no other changes to your project are required, and you should have no breaking changes. The previous 'hybrid' behavior is now the default, under a new name 'static'.

```
output: 'hybrid'
```

```
'hybrid'
```

```
'static'
```

```
import { defineConfig } from "astro/config";


export default defineConfig({
  output: 'hybrid',
});
```

```
import { defineConfig } from "astro/config";


export default defineConfig({
  output: 'hybrid',
});
```

If you were using the output: 'static' (default) option, you can continue to use it as before. By default, all of your pages will continue to be prerendered and you will have a completely static site. You should have no breaking changes to your project.

```
output: 'static'
```

An adapter is still required to deploy an Astro project with any server-rendered pages, no matter which output mode your project uses. Failure to include an adapter will result in a warning in development and an error at build time.

```
output
```

### Removed: support for dynamic prerender values in routes

```
prerender
```

In Astro 4.x, environment variables could be used to dynamically set the value of prerender exports in routes, for example export const prerender = import.meta.env.SOME_VAR.

```
prerender
```

```
export const prerender = import.meta.env.SOME_VAR
```

Astro v5.0 removes support for dynamic values in prerender exports. Only the static values true and false are supported.

```
prerender
```

```
true
```

```
false
```

#### What should I do?

- Remove any dynamic prerender exports in your routes:

src/pages/blog/[slug].astro
---
export const prerender = import.meta.env.SOME_VAR;
---
Remove any dynamic prerender exports in your routes:

```
prerender
```

```
---
export const prerender = import.meta.env.SOME_VAR;
---
```

```
---
export const prerender = import.meta.env.SOME_VAR;
---
```

- Use an Astro integration in your astro.config.mjs file to set prerender values that need to be dynamic in the "astro:route:setup" hook:

astro.config.mjs
import { defineConfig } from 'astro/config';
import { loadEnv } from 'vite';


export default defineConfig({
  integrations: [
    {
      name: 'set-prerender',
      hooks: {
        'astro:route:setup': ({ route }) => {
          // Load environment variables from .env files (if needed)
          const { PRERENDER } = loadEnv(process.env.NODE_ENV, process.cwd(), '');
          // Find routes matching the expected filename.
          if (route.component.endsWith('/blog/[slug].astro')) {
            // Set the prerender value on routes as needed.
            route.prerender = PRERENDER;
          }
        },
      },
    }
  ],
});
Use an Astro integration in your astro.config.mjs file to set prerender values that need to be dynamic in the "astro:route:setup" hook:

```
astro.config.mjs
```

```
prerender
```

```
"astro:route:setup"
```

```
import { defineConfig } from 'astro/config';
import { loadEnv } from 'vite';


export default defineConfig({
  integrations: [
    {
      name: 'set-prerender',
      hooks: {
        'astro:route:setup': ({ route }) => {
          // Load environment variables from .env files (if needed)
          const { PRERENDER } = loadEnv(process.env.NODE_ENV, process.cwd(), '');
          // Find routes matching the expected filename.
          if (route.component.endsWith('/blog/[slug].astro')) {
            // Set the prerender value on routes as needed.
            route.prerender = PRERENDER;
          }
        },
      },
    }
  ],
});
```

```
import { defineConfig } from 'astro/config';
import { loadEnv } from 'vite';


export default defineConfig({
  integrations: [
    {
      name: 'set-prerender',
      hooks: {
        'astro:route:setup': ({ route }) => {
          // Load environment variables from .env files (if needed)
          const { PRERENDER } = loadEnv(process.env.NODE_ENV, process.cwd(), '');
          // Find routes matching the expected filename.
          if (route.component.endsWith('/blog/[slug].astro')) {
            // Set the prerender value on routes as needed.
            route.prerender = PRERENDER;
          }
        },
      },
    }
  ],
});
```

### Removed: Squoosh image service

In Astro 4.x, you could configure image.service: squooshImageService() to use Squoosh to transform your images instead of Sharp. However, the underlying library libsquoosh is no longer maintained and has memory and performance issues.

```
image.service: squooshImageService()
```

```
libsquoosh
```

Astro 5.0 removes the Squoosh image optimization service entirely.

#### What should I do?

To switch to the built-in Sharp image service, remove the squooshImageService import from your Astro config. By default, you will use Sharp for astro:assets.

```
squooshImageService
```

```
astro:assets
```

```
import { squooshImageService } from "astro/config";
import { defineConfig } from "astro/config";


export default defineConfig({
 image: {
   service: squooshImageService()
 }
});
```

```
import { squooshImageService } from "astro/config";
import { defineConfig } from "astro/config";


export default defineConfig({
 image: {
   service: squooshImageService()
 }
});
```

If you are using a strict package manager like pnpm, you may need to install the sharp package manually to use the Sharp image service, even though it is built into Astro by default.

```
pnpm
```

```
sharp
```

If your adapter does not support Astro’s built-in Sharp image optimization, you can configure a no-op image service to allow you to use the <Image /> and <Picture /> components.

```
<Image />
```

```
<Picture />
```

Alternatively, you may wish to consider a community-maintained Squoosh image service if you are unable to use the Sharp image service.

##### For adapters

If your adapter previously precised its compatibility status with Squoosh, you should now remove this information from your adapter configuration.

```
supportedAstroFeatures: {
  assets: {
    isSquooshCompatible: true
  }
}
```

```
supportedAstroFeatures: {
  assets: {
    isSquooshCompatible: true
  }
}
```

### Removed: some public-facing types

In Astro v4.x, @types/astro.ts exposed all types publicly to users, whether or not they were still actively used or only intended for internal use.

```
@types/astro.ts
```

Astro v5.0 refactors this file to remove outdated and internal types. This refactor brings improvements to your editor (e.g. faster completions, lower memory usage, and more relevant completion options). However, this refactor may cause errors in some projects that have been relying on types that are no longer available to the public.

#### What should I do?

Remove any types that now cause errors in your project as you no longer have access to them. These are mostly APIs that have previously been deprecated and removed, but may also include types that are now internal.

### Experimental Flags

The following experimental flags have been removed in Astro v5.0 and these features are available for use:

- env
```
env
```

- serverIslands
```
serverIslands
```

Additionally, the following experimental flags have been removed and are now the default or recommended behavior in Astro v5.0.

- directRenderScript (See below for breaking changes to default <script> behavior.)
```
directRenderScript
```

```
<script>
```

- globalRoutePriority (See below for breaking changes to default route priority order.)
```
globalRoutePriority
```

- contentLayer (See guidance for upgrading existing content collections to the new, preferred Content Layer API.)
```
contentLayer
```

The following experimental flags have been removed and their corresponding features are not part of Astro v5.0.

- contentCollectionsCache
```
contentCollectionsCache
```

Remove these experimental flags if you were previously using them, and move your env configuration to the root of your Astro config:

```
env
```

```
import { defineConfig } from 'astro/config';


export default defineConfig({
  experimental: {
    directRenderScript: true,
    globalRoutePriority: true,
    contentLayer: true,
    serverIslands: true,
    contentCollectionsCache: true,
    env: {
      schema: {...}
    }
  },
  env: {
      schema: {...}
  }
})
```

```
import { defineConfig } from 'astro/config';


export default defineConfig({
  experimental: {
    directRenderScript: true,
    globalRoutePriority: true,
    contentLayer: true,
    serverIslands: true,
    contentCollectionsCache: true,
    env: {
      schema: {...}
    }
  },
  env: {
      schema: {...}
  }
})
```

These features are all available by default in Astro v5.0.

## Changed Defaults

Some default behavior has changed in Astro v5.0 and your project code may need updating to account for these changes.

In most cases, the only action needed is to review your existing project’s deployment and ensure that it continues to function as you expect, making updates to your code as necessary. In some cases, there may be a configuration setting to allow you to continue to use the previous default behavior.

### CSRF protection is now set by default

In Astro v4.x, The default value of security.checkOrigin was false. Previously, you had to explicitly set this value to true to enable Cross-Site Request Forgery (CSRF) protection.

```
security.checkOrigin
```

```
false
```

```
true
```

Astro v5.0 changes the default value of this option to true, and will automatically check that the “origin” header matches the URL sent by each request in on-demand rendered pages.

```
true
```

#### What should I do?

If you had previously configured security.checkOrigin: true, you no longer need this line in your Astro config. This is now the default.

```
security.checkOrigin: true
```

To disable this behavior, you must explicitly set security.checkOrigin: false.

```
security.checkOrigin: false
```

```
export default defineConfig({
  output: "server",
  security: {
    checkOrigin: false
  }
})
```

```
export default defineConfig({
  output: "server",
  security: {
    checkOrigin: false
  }
})
```

### Route priority order for injected routes and redirects

In Astro v4.x, experimental.globalRoutePriority was an optional flag that ensured that injected routes, file-based routes, and redirects were all prioritized using the route priority order rules for all routes. This allowed more control over routing in your project by not automatically prioritizing certain kinds of routes and standardizing the route priority order.

```
experimental.globalRoutePriority
```

Astro v5.0 removes this experimental flag and makes this the new default behavior in Astro: redirects and injected routes are now prioritized equally alongside file-based project routes.

Note that this was already the default behavior in Starlight, and should not affect updated Starlight projects.

#### What should I do?

If your project includes injected routes or redirects, please check that your routes are building page URLs as expected. An example of the new expected behavior is shown below.

In a project containing the following routes:

- File-based route: /blog/post/[pid]
```
/blog/post/[pid]
```

- File-based route: /[page]
```
/[page]
```

- Injected route: /blog/[...slug]
```
/blog/[...slug]
```

- Redirect: /blog/tags/[tag] -> /[tag]
```
/blog/tags/[tag] -> /[tag]
```

- Redirect: /posts -> /blog
```
/posts -> /blog
```

The following URLs will be built (instead of following the route priority order of Astro v4.x):

- /blog/tags/astro is built by the redirect to /tags/[tag] (instead of the injected route /blog/[...slug])
```
/blog/tags/astro
```

```
/tags/[tag]
```

```
/blog/[...slug]
```

- /blog/post/0 is built by the file-based route /blog/post/[pid] (instead of the injected route /blog/[...slug])
```
/blog/post/0
```

```
/blog/post/[pid]
```

```
/blog/[...slug]
```

- /posts is built by the redirect to /blog (instead of the file-based route /[page])
```
/posts
```

```
/blog
```

```
/[page]
```

In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes.

### <script> tags are rendered directly as declared

```
<script>
```

In Astro v4.x, experimental.directRenderScript was an optional flag to directly render <scripts> as declared in .astro files (including existing features like TypeScript, importing node_modules, and deduplicating scripts). This strategy prevented scripts from being executed in places where they were not used. Additionally, conditionally rendered scripts were previously implicitly inlined, as if an is:inline directive was automatically added to them.

```
experimental.directRenderScript
```

```
<scripts>
```

```
.astro
```

```
node_modules
```

```
is:inline
```

Astro 5.0 removes this experimental flag and makes this the new default behavior in Astro: scripts are no longer hoisted to the <head>, multiple scripts on a page are no longer bundled together, and a <script> tag may interfere with CSS styling. Additionally, conditionally rendered scripts are no longer implicitly inlined.

```
<head>
```

```
<script>
```

#### What should I do?

Please review your <script> tags and ensure they behave as desired.

```
<script>
```

If you previously had conditionally rendered <script> tags, you will need to add an is:inline attribute to preserve the same behavior as before:

```
<script>
```

```
is:inline
```

```
---
type Props = {
  showAlert: boolean
}


const { showAlert } = Astro.props;
---
{
  showAlert && <script is:inline>alert("Some very important code!!")</script>
}
```

```
---
type Props = {
  showAlert: boolean
}


const { showAlert } = Astro.props;
---
{
  showAlert && <script is:inline>alert("Some very important code!!")</script>
}
```

```
script
```

## Breaking Changes

The following changes are considered breaking changes in Astro v5.0. Breaking changes may or may not provide temporary backwards compatibility. If you were using these features, you may have to update your code as recommended in each entry.

### Renamed: <ViewTransitions /> component

```
<ViewTransitions />
```

In Astro 4.x, Astro’s View Transitions API included a <ViewTransitions /> router component to enable client-side routing, page transitions, and more.

```
<ViewTransitions />
```

Astro 5.0 renames this component to <ClientRouter /> to clarify the role of the component within the API. This makes it more clear that the features you get from Astro’s <ClientRouter /> routing component are slightly different from the native CSS-based MPA router.

```
<ClientRouter />
```

```
<ClientRouter />
```

No functionality has changed. This component has only changed its name.

#### What should I do?

Replace all occurrences of the ViewTransitions import and component with ClientRouter:

```
ViewTransitions
```

```
ClientRouter
```

```
import { ViewTransitions } from 'astro:transitions';
import { ClientRouter } from 'astro:transitions';


<html>
  <head>
    ...
   <ViewTransitions />
   <ClientRouter />
  </head>
</html>
```

```
import { ViewTransitions } from 'astro:transitions';
import { ClientRouter } from 'astro:transitions';


<html>
  <head>
    ...
   <ViewTransitions />
   <ClientRouter />
  </head>
</html>
```

### Changed: TypeScript configuration

In Astro v4.x, Astro relied on a src/env.d.ts file for type inferencing and defining modules for features that relied on generated types.

```
src/env.d.ts
```

Astro 5.0 instead uses a .astro/types.d.ts file for type inferencing, and now recommends setting include and exclude in tsconfig.json to benefit from Astro types and avoid checking built files.

```
.astro/types.d.ts
```

```
include
```

```
exclude
```

```
tsconfig.json
```

Running astro sync no longer creates, nor updates, src/env.d.ts as it is not required for type-checking standard Astro projects.

```
astro sync
```

```
src/env.d.ts
```

#### What should I do?

To update your project to Astro’s recommended TypeScript settings, add the following include and exclude properties to your existing tsconfig.json:

```
include
```

```
exclude
```

```
tsconfig.json
```

```
{
  "extends": "astro/tsconfigs/base",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}
```

```
{
  "extends": "astro/tsconfigs/base",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}
```

Note that src/env.d.ts is only necessary if you have added custom configurations, or if you’re not using a tsconfig.json file.

```
src/env.d.ts
```

```
tsconfig.json
```

### Changed: Actions submitted by HTML forms no longer use cookie redirects

In Astro 4.x, actions called from an HTML form would trigger a redirect with the result forwarded using cookies. This caused issues for large form errors and return values that exceeded the 4 KB limit of cookie-based storage.

Astro 5.0 now renders the result of an action as a POST result without any forwarding. This will introduce a “confirm form resubmission?” dialog when a user attempts to refresh the page, though it no longer imposes a 4 KB limit on action return value.

#### What should I do?

You should update handling for action results that relies on redirects, and optionally address the “confirm form resubmission?” dialog with middleware.

##### To redirect to the previous route on error

If your HTML form action is directed to a different route (i.e. action={"/success-page" + actions.name}), Astro will no longer redirect to the previous route on error. You can implement this behavior manually using redirects from your Astro component. This example instead redirects to a new route on success, and handles errors on the current page otherwise:

```
action={"/success-page" + actions.name}
```

```
---
import { actions } from 'astro:actions';


const result = Astro.getActionResult(actions.newsletter);
if (!result?.error) {
  // Embed relevant result data in the URL if needed
  // example: redirect(`/confirmation?email=${result.data.email}`);
  return redirect('/confirmation');
}
---


<form method="POST" action={'/confirmation' + actions.newsletter}>
  <label>E-mail <input required type="email" name="email" /></label>
  <button>Sign up</button>
</form>
```

```
---
import { actions } from 'astro:actions';


const result = Astro.getActionResult(actions.newsletter);
if (!result?.error) {
  // Embed relevant result data in the URL if needed
  // example: redirect(`/confirmation?email=${result.data.email}`);
  return redirect('/confirmation');
}
---


<form method="POST" action={'/confirmation' + actions.newsletter}>
  <label>E-mail <input required type="email" name="email" /></label>
  <button>Sign up</button>
</form>
```

##### (Optional) To remove the confirm dialog on refresh

To address the “confirm form resubmission?” dialog on refresh, or to preserve action results across sessions, you can now customize action result handling from middleware.

We recommend using a session storage provider as described in our Netlify Blob example. However, if you prefer the cookie forwarding behavior from 4.X and accept the 4 KB size limit, you can implement the pattern as shown in this sample snippet:

```
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';


export const onRequest = defineMiddleware(async (context, next) => {
  // Skip requests for prerendered pages
  if (context.isPrerendered) return next();


  const { action, setActionResult, serializeActionResult } = getActionContext(context);


  // If an action result was forwarded as a cookie, set the result
  // to be accessible from `Astro.getActionResult()`
  const payload = context.cookies.get('ACTION_PAYLOAD');
  if (payload) {
    const { actionName, actionResult } = payload.json();
    setActionResult(actionName, actionResult);
    context.cookies.delete('ACTION_PAYLOAD', { path: '/' });
    return next();
  }


  // If an action was called from an HTML form action,
  // call the action handler and redirect with the result as a cookie.
  if (action?.calledFrom === 'form') {
    const actionResult = await action.handler();


    context.cookies.set('ACTION_PAYLOAD', {
      actionName: action.name,
      actionResult: serializeActionResult(actionResult),
    }, {
      path: '/',
      httpOnly: true,
      sameSite: 'lax',
      maxAge: 60
    });


    if (actionResult.error) {
    // Redirect back to the previous page on error
      const referer = context.request.headers.get('Referer');
      if (!referer) {
        throw new Error('Internal: Referer unexpectedly missing from Action POST request.');
      }
      return context.redirect(referer);
    }
    // Redirect to the destination page on success
    return context.redirect(context.originPathname);
  }


  return next();
})
```

```
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';


export const onRequest = defineMiddleware(async (context, next) => {
  // Skip requests for prerendered pages
  if (context.isPrerendered) return next();


  const { action, setActionResult, serializeActionResult } = getActionContext(context);


  // If an action result was forwarded as a cookie, set the result
  // to be accessible from `Astro.getActionResult()`
  const payload = context.cookies.get('ACTION_PAYLOAD');
  if (payload) {
    const { actionName, actionResult } = payload.json();
    setActionResult(actionName, actionResult);
    context.cookies.delete('ACTION_PAYLOAD', { path: '/' });
    return next();
  }


  // If an action was called from an HTML form action,
  // call the action handler and redirect with the result as a cookie.
  if (action?.calledFrom === 'form') {
    const actionResult = await action.handler();


    context.cookies.set('ACTION_PAYLOAD', {
      actionName: action.name,
      actionResult: serializeActionResult(actionResult),
    }, {
      path: '/',
      httpOnly: true,
      sameSite: 'lax',
      maxAge: 60
    });


    if (actionResult.error) {
    // Redirect back to the previous page on error
      const referer = context.request.headers.get('Referer');
      if (!referer) {
        throw new Error('Internal: Referer unexpectedly missing from Action POST request.');
      }
      return context.redirect(referer);
    }
    // Redirect to the destination page on success
    return context.redirect(context.originPathname);
  }


  return next();
})
```

### Changed: compiledContent() is now an async function

```
compiledContent()
```

In Astro 4.x, top level await was included in Markdown modules. This caused some issues with custom image services and images inside Markdown, causing Node to suddenly exit with no error message.

Astro 5.0 makes the compiledContent() property on Markdown import an async function, requiring an await to resolve the content.

```
compiledContent()
```

```
await
```

#### What should I do?

Update your code to use await when calling compiledContent().

```
await
```

```
compiledContent()
```

```
---
import * as myPost from "../blog/post.md";


const content = myPost.compiledContent();
const content = await myPost.compiledContent();
---


<Fragment set:html={content} />
```

```
---
import * as myPost from "../blog/post.md";


const content = myPost.compiledContent();
const content = await myPost.compiledContent();
---


<Fragment set:html={content} />
```

```
compiledContent()
```

### Changed: astro:content can no longer be used on the client

```
astro:content
```

In Astro 4.x, it was possible to access the astro:content module on the client.

```
astro:content
```

Astro 5.0 removes this access as it was never intentionally exposed for client use. Using astro:content this way had limitations and bloated client bundles.

```
astro:content
```

#### What should I do?

If you are currently using astro:content in the client, pass the data you need through props to your client components instead:

```
astro:content
```

```
---
import { getCollection } from 'astro:content';
import ClientComponent from '../components/ClientComponent';


const posts = await getCollection('blog');
const postsData = posts.map(post => post.data);
---


<ClientComponent posts={postsData} />
```

```
---
import { getCollection } from 'astro:content';
import ClientComponent from '../components/ClientComponent';


const posts = await getCollection('blog');
const postsData = posts.map(post => post.data);
---


<ClientComponent posts={postsData} />
```

```
astro:content
```

### Renamed: Shiki css-variables theme color token names

```
css-variables
```

In Astro v4.x, the Shiki css-variables theme used the --astro-code-color-text and --astro-code-color-background tokens for styling the foreground and background colors of code blocks respectively.

```
css-variables
```

```
--astro-code-color-text
```

```
--astro-code-color-background
```

Astro v5.0 renames them to --astro-code-foreground and --astro-code-background respectively to better align with the Shiki v1 defaults.

```
--astro-code-foreground
```

```
--astro-code-background
```

#### What should I do?

You can perform a global find and replace in your project to migrate to the new token names.

```
:root {
  --astro-code-color-text: #000;
  --astro-code-color-background: #fff;
  --astro-code-foreground: #000;
  --astro-code-background: #fff;
}
```

```
:root {
  --astro-code-color-text: #000;
  --astro-code-color-background: #fff;
  --astro-code-foreground: #000;
  --astro-code-background: #fff;
}
```

### Changed: internal Shiki rehype plugin for highlighting code blocks

In Astro 4.x, Astro’s internal Shiki rehype plugin highlighted code blocks as HTML.

Astro 5.0 updates this plugin to highlight code blocks as hast. This allows a more direct Markdown and MDX processing and improves the performance when building the project. However, this may cause issues with existing Shiki transformers.

#### What should I do?

If you are using Shiki transformers passed to markdown.shikiConfig.transformers, you must make sure they do not use the postprocess hook. This hook no longer runs on code blocks in .md and .mdx files. (See the Shiki documentation on transformer hooks for more information).

```
markdown.shikiConfig.transformers
```

```
postprocess
```

```
.md
```

```
.mdx
```

Code blocks in .mdoc files and Astro’s built-in <Code /> component do not use the internal Shiki rehype plugin and are unaffected.

```
.mdoc
```

```
<Code />
```

### Changed: Automatic charset=utf-8 behavior for Markdown and MDX pages

```
charset=utf-8
```

In Astro 4.0, Markdown and MDX pages (located in src/pages/) automatically responded with charset=utf-8 in the Content-Type header, which allowed rendering non-ASCII characters in your pages.

```
src/pages/
```

```
charset=utf-8
```

```
Content-Type
```

Astro 5.0 updates the behaviour to add the <meta charset="utf-8"> tag instead, and only for pages that do not use Astro’s special layout frontmatter property. Similarly for MDX pages, Astro will only add the tag if the MDX content does not import a wrapping Layout component.

```
<meta charset="utf-8">
```

```
layout
```

```
Layout
```

If your Markdown or MDX pages use the layout frontmatter property, or if the MDX page content imports a wrapping Layout component, then the HTML encoding will be handled by the designated layout component instead, and the <meta charset="utf-8"> tag will not be added to your page by default.

```
layout
```

```
Layout
```

```
<meta charset="utf-8">
```

#### What should I do?

If you require charset=utf-8 to render your page correctly, make sure that your layout components contain the <meta charset="utf-8"> tag. You may need to add this if you have not already done so.

```
charset=utf-8
```

```
<meta charset="utf-8">
```

### Changed: Astro-specific metadata attached in remark and rehype plugins

In Astro 4.x, the Astro-specific metadata attached to vfile.data in remark and rehype plugins was attached in different locations with inconsistent names.

```
vfile.data
```

Astro 5 cleans up the API and the metadata is now renamed as below:

- vfile.data.__astroHeadings -> vfile.data.astro.headings
```
vfile.data.__astroHeadings
```

```
vfile.data.astro.headings
```

- vfile.data.imagePaths -> vfile.data.astro.imagePaths
```
vfile.data.imagePaths
```

```
vfile.data.astro.imagePaths
```

The types of imagePaths has also been updated from Set<string> to string[]. The vfile.data.astro.frontmatter metadata is left unchanged.

```
imagePaths
```

```
Set<string>
```

```
string[]
```

```
vfile.data.astro.frontmatter
```

#### What should I do?

While we don’t consider these APIs public, they can be accessed by remark and rehype plugins that want to re-use Astro’s metadata. If you are using these APIs, make sure to access them in the new locations.

### Changed: image endpoint configuration

In Astro 4.x, you could set an endpoint in your image configuration to use for image optimization.

```
image
```

Astro 5.0 allows you to customize a route and entrypoint of the image.endpoint config. This can be useful in niche situations where the default route /_image conflicts with an existing route or your local server setup.

```
route
```

```
entrypoint
```

```
image.endpoint
```

```
/_image
```

#### What should I do?

If you had previously customized image.endpoint, move this endpoint to the new endpoint.entrypoint property. Optionally, you may customize a route:

```
image.endpoint
```

```
endpoint.entrypoint
```

```
route
```

```
import { defineConfig } from "astro/config";


defineConfig({
  image: {
    endpoint: './src/image-endpoint.ts',
    endpoint: {
      route: "/image",
      entrypoint: "./src/image_endpoint.ts"
    }
  },
})
```

```
import { defineConfig } from "astro/config";


defineConfig({
  image: {
    endpoint: './src/image-endpoint.ts',
    endpoint: {
      route: "/image",
      entrypoint: "./src/image_endpoint.ts"
    }
  },
})
```

### Changed: build.client and build.server resolve behavior

```
build.client
```

```
build.server
```

In Astro v4.x, the build.client and build.server options were documented to resolve relatively from the outDir option, but it didn’t always work as expected.

```
build.client
```

```
build.server
```

```
outDir
```

Astro 5.0 fixes the behavior to correctly resolve from the outDir option. For example, if outDir is set to ./dist/nested/, then by default:

```
outDir
```

```
outDir
```

```
./dist/nested/
```

- build.client will resolve to <root>/dist/nested/client/
```
build.client
```

```
<root>/dist/nested/client/
```

- build.server will resolve to <root>/dist/nested/server/
```
build.server
```

```
<root>/dist/nested/server/
```

Previously the values were incorrectly resolved:

- build.client was resolved to <root>/dist/nested/dist/client/
```
build.client
```

```
<root>/dist/nested/dist/client/
```

- build.server was resolved to <root>/dist/nested/dist/server/
```
build.server
```

```
<root>/dist/nested/dist/server/
```

#### What should I do?

If you were relying on the previous build paths, make sure that your project code is updated to the new build paths.

```
build
```

### Changed: JS dependencies in config file are no longer processed by Vite

In Astro 4.x, locally-linked JS dependencies (e.g. npm link, in a monorepo, etc) were able to use Vite features like import.meta.glob when imported by the Astro config file.

```
npm link
```

```
import.meta.glob
```

Astro 5 updates the Astro config loading flow to ignore processing locally-linked JS dependencies with Vite. Dependencies exporting raw TypeScript files are unaffected. Instead, these JS dependencies will be normally imported by the Node.js runtime the same way as other dependencies from node_modules.

```
node_modules
```

This change was made as the previous behavior caused confusion among integration authors who tested against a package that worked locally, but not when published. It also restricted using CJS-only dependencies because Vite required the code to be ESM. While this change only affects JS dependencies, it’s also recommended for packages to export JavaScript instead of raw TypeScript where possible to prevent accidental Vite-specific usage as it’s an implementation detail of Astro’s config loading flow.

#### What should I do?

Make sure your locally-linked JS dependencies are built before running your Astro project. Then, the config loading should work as before.

### Changed: URLs returned by paginate()

```
paginate()
```

In Astro v4.x, the URL returned by paginate() (e.g. page.url.next, page.url.first, etc.) did not include the value set for base in your Astro config. You had to manually prepend your configured value for base to the URL path.

```
paginate()
```

```
page.url.next
```

```
page.url.first
```

```
base
```

```
base
```

Astro 5.0 automatically includes the base value in page.url.

```
base
```

```
page.url
```

#### What should I do?

If you are using the paginate() function for these URLs, remove any existing base value as it is now added for you:

```
paginate()
```

```
base
```

```
---
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  return paginate(astronautPages, { pageSize: 1 });
}
const { page } = Astro.props;
// `base: /'docs'` configured in `astro.config.mjs`
const prev = "/docs" + page.url.prev;
const prev = page.url.prev;
---
<a id="prev" href={prev}>Back</a>
```

```
---
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  return paginate(astronautPages, { pageSize: 1 });
}
const { page } = Astro.props;
// `base: /'docs'` configured in `astro.config.mjs`
const prev = "/docs" + page.url.prev;
const prev = page.url.prev;
---
<a id="prev" href={prev}>Back</a>
```

### Changed: non-boolean HTML attribute values

In Astro v4.x, non-boolean HTML attributes may not have included their values when rendered to HTML.

Astro v5.0 renders the values explicitly as ="true" or ="false", matching proper attribute handling in browsers.

```
="true"
```

```
="false"
```

In the following .astro examples, only allowfullscreen is a boolean attribute:

```
.astro
```

```
allowfullscreen
```

```
<!-- `allowfullscreen` is a boolean attribute -->
<p allowfullscreen={true}></p>
<p allowfullscreen={false}></p>
<!-- `inherit` is *not* a boolean attribute -->
<p inherit={true}></p>
<p inherit={false}></p>
<!-- `data-*` attributes are not boolean attributes -->
<p data-light={true}></p>
<p data-light={false}></p>
```

```
<!-- `allowfullscreen` is a boolean attribute -->
<p allowfullscreen={true}></p>
<p allowfullscreen={false}></p>
<!-- `inherit` is *not* a boolean attribute -->
<p inherit={true}></p>
<p inherit={false}></p>
<!-- `data-*` attributes are not boolean attributes -->
<p data-light={true}></p>
<p data-light={false}></p>
```

Astro v5.0 now preserves the full data attribute with its value when rendering the HTML of non-boolean attributes:

```
<p allowfullscreen></p>
<p></p>


<p inherit="true"></p>
<p inherit></p>
<p inherit="false"></p>


<p data-light></p>
<p data-light="true"></p>
<p></p>
<p data-light="false"></p>
```

```
<p allowfullscreen></p>
<p></p>


<p inherit="true"></p>
<p inherit></p>
<p inherit="false"></p>


<p data-light></p>
<p data-light="true"></p>
<p></p>
<p data-light="false"></p>
```

#### What should I do?

If you rely on attribute values, for example, to locate elements or to conditionally render, update your code to match the new non-boolean attribute values:

```
el.getAttribute('inherit') === ''
el.getAttribute('inherit') === 'false'


el.hasAttribute('data-light')
el.dataset.light === 'true'
```

```
el.getAttribute('inherit') === ''
el.getAttribute('inherit') === 'false'


el.hasAttribute('data-light')
el.dataset.light === 'true'
```

### Changed: adding values to context.locals

```
context.locals
```

In Astro 4.x, it was possible to completely replace the entire locals object in middleware, API endpoints, and pages when adding new values.

```
locals
```

Astro 5.0 requires you to append values to the existing locals object without deleting it. Locals in middleware, API endpoints, and pages, can no longer be completely overridden.

```
locals
```

#### What should I do?

Where you previously were overwriting the object, you must now instead assign values to it:

```
ctx.locals = {
Object.assign(ctx.locals, {
  one: 1,
  two: 2
}
})
```

```
ctx.locals = {
Object.assign(ctx.locals, {
  one: 1,
  two: 2
}
})
```

```
context.locals
```

### Changed: params no longer decoded

```
params
```

In Astro v4.x, params passed to getStaticPath() were automatically decoded using decodeURIComponent.

```
params
```

```
getStaticPath()
```

```
decodeURIComponent
```

Astro v5.0 no longer decodes the value of params passed to getStaticPaths. You must manually decode them yourself if needed.

```
params
```

```
getStaticPaths
```

#### What should I do?

If you were previously relying on the automatic decoding, use decodeURI when passing params.

```
decodeURI
```

```
params
```

```
---
export function getStaticPaths() {
  return [
    { params: { id: "%5Bpage%5D" } },
    { params: { id: decodeURI("%5Bpage%5D") } },
  ]
}


const { id } = Astro.params;
---
```

```
---
export function getStaticPaths() {
  return [
    { params: { id: "%5Bpage%5D" } },
    { params: { id: decodeURI("%5Bpage%5D") } },
  ]
}


const { id } = Astro.params;
---
```

Note that the use of decodeURIComponent is discouraged for getStaticPaths because it decodes more characters than it should, for example /, ?, # and more.

```
decodeURIComponent
```

```
getStaticPaths
```

```
/
```

```
?
```

```
#
```

```
params
```

### Changed: RouteData type replaced by IntegrationsRouteData (Integrations API)

```
RouteData
```

```
IntegrationsRouteData
```

In Astro v4.x, the entryPoints type inside the astro:build:ssr and astro:build:done hooks was RouteData.

```
entryPoints
```

```
astro:build:ssr
```

```
astro:build:done
```

```
RouteData
```

Astro v5.0 the entryPoints type is now IntegrationRouteData, which contains a subset of the RouteData type. The fields isIndex and fallbackRoutes were removed.

```
entryPoints
```

```
IntegrationRouteData
```

```
RouteData
```

```
isIndex
```

```
fallbackRoutes
```

#### What should I do?

Update your adapter to change the type of entryPoints from RouteData to IntegrationRouteData.

```
entryPoints
```

```
RouteData
```

```
IntegrationRouteData
```

```
import type {RouteData} from 'astro';
import type {IntegrationRouteData} from "astro"


function useRoute(route: RouteData) {
function useRoute(route: IntegrationRouteData) {
}
```

```
import type {RouteData} from 'astro';
import type {IntegrationRouteData} from "astro"


function useRoute(route: RouteData) {
function useRoute(route: IntegrationRouteData) {
}
```

```
IntegrationRouteData
```

### Changed: distURL is now an array (Integrations API)

```
distURL
```

In Astro v4.x, RouteData.distURL was undefined or a URL.

```
RouteData.distURL
```

```
undefined
```

```
URL
```

Astro v5.0 updates the shape of IntegrationRouteData.distURL to be undefined or an array of URLs. This fixes a previous error because a route can generate multiple files on disk, especially when using dynamic routes such as [slug] or [...slug].

```
IntegrationRouteData.distURL
```

```
undefined
```

```
URL
```

```
[slug]
```

```
[...slug]
```

#### What should I do?

Update your code to handle IntegrationRouteData.distURL as an array.

```
IntegrationRouteData.distURL
```

```
if (route.distURL) {
  if (route.distURL.endsWith('index.html')) {
    // do something
  }
  for (const url of route.distURL) {
    if (url.endsWith('index.html')) {
      // do something
    }
  }
}
```

```
if (route.distURL) {
  if (route.distURL.endsWith('index.html')) {
    // do something
  }
  for (const url of route.distURL) {
    if (url.endsWith('index.html')) {
      // do something
    }
  }
}
```

```
IntegrationRouteData
```

### Changed: Arguments passed to app.render() (Adapter API)

```
app.render()
```

In Astro 4.x, The Adapter API method app.render() could receive three arguments: a mandatory request, an object of options or a routeData object, and locals.

```
app.render()
```

```
request
```

```
routeData
```

```
locals
```

Astro 5.0 combines these last two arguments into a single options argument named renderOptions.

```
renderOptions
```

#### What should I do?

Pass an object as the second argument to app.render(), which can include routeData and locals as properties.

```
app.render()
```

```
routeData
```

```
locals
```

```
const response = await app.render(request, routeData, locals);
const response = await app.render(request, {routeData, locals});
```

```
const response = await app.render(request, routeData, locals);
const response = await app.render(request, {routeData, locals});
```

```
renderOptions
```

### Changed: Properties on supportedAstroFeatures (Adapter API)

```
supportedAstroFeatures
```

In Astro 4.x, supportedAstroFeatures, which allows adapter authors to specify which features their integration supports, included an assets property to specify which of Astro’s image services were supported.

```
supportedAstroFeatures
```

```
assets
```

Astro 5.0 replaces this property with a dedicated sharpImageService property, used to determine whether the adapter is compatible with the built-in sharp image service.

```
sharpImageService
```

v5.0 also adds a new limited value for the different properties of supportedAstroFeatures for adapters, which indicates that the adapter is compatible with the feature, but with some limitations. This is useful for adapters that support a feature, but not in all cases or with all options.

```
limited
```

```
supportedAstroFeatures
```

Additionally, the value of the different properties on supportedAstroFeatures for adapters can now be objects, with support and message properties. The content of the message property will show a helpful message in the Astro CLI when the adapter is not compatible with a feature. This is notably useful with the new limited value, to explain to the user why support is limited.

```
supportedAstroFeatures
```

```
support
```

```
message
```

```
message
```

```
limited
```

#### What should I do?

If you were using the assets property, remove this as it is no longer available. To specify that your adapter supports the built-in sharp image service, replace this with sharpImageService.

```
assets
```

```
sharpImageService
```

You may also wish to update your supported features with the new limited option and include a message about your adapter’s support.

```
limited
```

```
supportedAstroFeatures: {
  assets: {
    supportKind: "stable",
    isSharpCompatible: true,
    isSquooshCompatible: true,
  },
  sharpImageService: {
    support: "limited",
    message: 'This adapter supports the built-in sharp image service, but with some limitations.'
  }
}
```

```
supportedAstroFeatures: {
  assets: {
    supportKind: "stable",
    isSharpCompatible: true,
    isSquooshCompatible: true,
  },
  sharpImageService: {
    support: "limited",
    message: 'This adapter supports the built-in sharp image service, but with some limitations.'
  }
}
```

### Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)

In Astro 4.x, when building a dev toolbar app, it was still possible to use the previously deprecated addDevToolbarApp(string); signature. The id, title, and icon properties to define the app were then made available through the default export of the app’s entrypoint.

```
addDevToolbarApp(string);
```

```
id
```

```
title
```

```
icon
```

```
entrypoint
```

Astro 5.0 completely removes this option entirely in favor of the current object shape when defining a dev toolbar app in an integration that’s more intuitive and allows Astro to provide better errors when toolbar apps fail to load correctly.

#### What should I do?

If you were using the deprecated shape, update your dev toolbar app to use the new shape:

```
// Old shape
addDevToolbarApp("./my-dev-toolbar-app.mjs");


// New shape
addDevToolbarApp({
  id: "my-app",
  name: "My App",
  icon: "<svg>...</svg>",
  entrypoint: "./my-dev-toolbar-app.mjs",
});
```

```
// Old shape
addDevToolbarApp("./my-dev-toolbar-app.mjs");


// New shape
addDevToolbarApp({
  id: "my-app",
  name: "My App",
  icon: "<svg>...</svg>",
  entrypoint: "./my-dev-toolbar-app.mjs",
});
```

```
export default {
  id: 'my-dev-toolbar-app',
  title: 'My Dev Toolbar App',
  icon: '🚀',
  init() {
    // ...
  }
}
```

```
export default {
  id: 'my-dev-toolbar-app',
  title: 'My Dev Toolbar App',
  icon: '🚀',
  init() {
    // ...
  }
}
```

### Removed: configuring Typescript during create-astro

```
create-astro
```

In Astro v4.x, it was possible to choose between Astro’s three TypeScript settings when creating a new project using create astro, either by answering a question or by passing an associated --typescript flag with the desired TypeScript setting.

```
create astro
```

```
--typescript
```

Astro 5.0 updates the create astro CLI command to remove the TypeScript question and its associated --typescript flag. The “strict” preset is now the default for all new projects created with the command line and it is no longer possible to customize this at that time. However, the TypeScript template can still be changed manually in tsconfig.json.

```
create astro
```

```
--typescript
```

```
tsconfig.json
```

#### What should I do?

If you were using the --typescript flag with create-astro, remove it from your command.

```
--typescript
```

```
create-astro
```

- npm
- pnpm
- Yarn
```
npm create astro@latest -- --template <example-name> --typescript strict
npm create astro@latest -- --template <example-name>
```

```
npm create astro@latest -- --template <example-name> --typescript strict
npm create astro@latest -- --template <example-name>
```

```
pnpm create astro@latest --template <example-name> --typescript strictpnpm create astro@latest --template <example-name>
```

```
pnpm create astro@latest --template <example-name> --typescript strictpnpm create astro@latest --template <example-name>
```

```
yarn create astro --template <example-name> --typescript strictyarn create astro --template <example-name>
```

```
yarn create astro --template <example-name> --typescript strictyarn create astro --template <example-name>
```

```
create astro
```

## Community Resources

Know a good resource for Astro v5.0? Edit this page and add a link below!

## Known Issues

Please check Astro’s issues on GitHub for any reported issues, or to file an issue yourself.

## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

