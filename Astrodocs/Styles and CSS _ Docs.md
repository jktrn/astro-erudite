- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
Pages
Routing
Endpoints
Middleware
Internationalization (i18n)
Prefetch
View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
Components
Layouts
Styles and CSS
Fonts
Syntax Highlighting
Scripts and event handling
Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
Markdown
Content collections
Images
Data fetching
Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
On-demand rendering
Server islands
Actions
Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
Upgrade Astro
Major upgrade guides
- Upgrade Astro
- Major upgrade guides
- Troubleshooting
- How-to recipes
- Contribute to Astro
- Astro Template Syntax
								
							
							
	



						
						
	
				
						Template expressions reference
						
					
			
				
						Template directives reference
- Template expressions reference
- Template directives reference
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
								
							
							
	



						
						
	
				
						Render context
						
					
			
				
						astro:actions
						
					
			
				
						astro:assets
						
					
			
				
						astro:config
						
					
			
				
						astro:content
						
					
			
				
						astro:env
						
					
			
				
						astro:i18n
						
					
			
				
						astro:middleware
						
					
			
				
						astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
								
							
							
	



						
						
	
				
						Integration API
						
					
			
				
						Adapter API
						
					
			
				
						Content Loader API
						
					
			
				
						Image Service API
						
					
			
				
						Dev Toolbar App API
						
					
			
				
						Container API (experimental)
						
					
			
				
						Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
								
							
							
	



						
						
	
				
						Configuring experimental flags
						
					
			
				
						Content Security Policy
						
					
			
				
						Fonts
						
					
			
				
						Live content collections
						
					
			
				
						Client prerendering
						
					
			
				
						Intellisense for collections
						
					
			
				
						Preserve scripts order
						
					
			
				
						Markdown heading ID compatibility
						
					
			
				
						Private meta environment variables inlining
						
					
			
				
						Chrome DevTools workspace
						
					
			
				
						Prerender conflict error
						
					
			
				
						SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- Styling in Astro
				
				
	
				
					Scoped Styles
				
				
			
				
					Global Styles
				
				
			
				
					Combining classes with class:list
				
				
			
				
					CSS Variables
				
				
			
				
					Passing a class to a child component
				
				
			
				
					Inline styles
- Scoped Styles
- Global Styles
- Combining classes with class:list
- CSS Variables
- Passing a class to a child component
- Inline styles
- External Styles
				
				
	
				
					Import a local stylesheet
				
				
			
				
					Import a stylesheet from an npm package
				
				
			
				
					Load a static stylesheet via ‚Äúlink‚Äù tags
- Import a local stylesheet
- Import a stylesheet from an npm package
- Load a static stylesheet via ‚Äúlink‚Äù tags
- Cascading Order
				
				
	
				
					Scoped Styles
				
				
			
				
					Import Order
				
				
			
				
					Link Tags
- Scoped Styles
- Import Order
- Link Tags
- Tailwind
				
				
	
				
					Add Tailwind 4
				
				
			
				
					Upgrade from Tailwind 3
				
				
			
				
					Legacy Tailwind 3 support
- Add Tailwind 4
- Upgrade from Tailwind 3
- Legacy Tailwind 3 support
- CSS Preprocessors
				
				
	
				
					Sass and SCSS
				
				
			
				
					Stylus
				
				
			
				
					Less
				
				
			
				
					LightningCSS
				
				
			
				
					In framework components
- Sass and SCSS
- Stylus
- Less
- LightningCSS
- In framework components
- PostCSS
- Frameworks and Libraries
				
				
	
				
					üìò React / Preact
				
				
			
				
					üìó Vue
				
				
			
				
					üìï Svelte
- üìò React / Preact
- üìó Vue
- üìï Svelte
- Markdown Styling
- Production
				
				
	
				
					Bundle control
- Bundle control
- Advanced
				
				
	
				
					?raw CSS Imports
				
				
			
				
					?url CSS Imports
- ?raw CSS Imports
- ?url CSS Imports
## On this page

- Overview
- Styling in Astro
Scoped Styles
Global Styles
Combining classes with class:list
CSS Variables
Passing a class to a child component
Inline styles
- Scoped Styles
- Global Styles
- Combining classes with class:list
- CSS Variables
- Passing a class to a child component
- Inline styles
- External Styles
Import a local stylesheet
Import a stylesheet from an npm package
Load a static stylesheet via ‚Äúlink‚Äù tags
- Import a local stylesheet
- Import a stylesheet from an npm package
- Load a static stylesheet via ‚Äúlink‚Äù tags
- Cascading Order
Scoped Styles
Import Order
Link Tags
- Scoped Styles
- Import Order
- Link Tags
- Tailwind
Add Tailwind 4
Upgrade from Tailwind 3
Legacy Tailwind 3 support
- Add Tailwind 4
- Upgrade from Tailwind 3
- Legacy Tailwind 3 support
- CSS Preprocessors
Sass and SCSS
Stylus
Less
LightningCSS
In framework components
- Sass and SCSS
- Stylus
- Less
- LightningCSS
- In framework components
- PostCSS
- Frameworks and Libraries
üìò React / Preact
üìó Vue
üìï Svelte
- üìò React / Preact
- üìó Vue
- üìï Svelte
- Markdown Styling
- Production
Bundle control
- Bundle control
- Advanced
?raw CSS Imports
?url CSS Imports
- ?raw CSS Imports
- ?url CSS Imports
## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

# Styles and CSS

Astro was designed to make styling and writing CSS a breeze. Write your own CSS directly inside of an Astro component or import your favorite CSS library like Tailwind. Advanced styling languages like Sass and Less are also supported.

## Styling in Astro

Styling an Astro component is as easy as adding a <style> tag to your component or page template. When you place a <style> tag inside of an Astro component, Astro will detect the CSS and handle your styles for you, automatically.

```
<style>
```

```
<style>
```

```
<style>
  h1 { color: red; }
</style>
```

```
<style>
  h1 { color: red; }
</style>
```

### Scoped Styles

Astro <style> CSS rules are automatically scoped by default. Scoped styles are compiled behind-the-scenes to only apply to HTML written inside of that same component. The CSS that you write inside of an Astro component is automatically encapsulated inside of that component.

```
<style>
```

This CSS:

```
<style>
  h1 {
    color: red;
  }


  .text {
    color: blue;
  }
</style>
```

```
<style>
  h1 {
    color: red;
  }


  .text {
    color: blue;
  }
</style>
```

Compiles to this:

```
<style>
  h1[data-astro-cid-hhnqfkh6] {
     color: red;
  }


  .text[data-astro-cid-hhnqfkh6] {
    color: blue;
  }
</style>
```

```
<style>
  h1[data-astro-cid-hhnqfkh6] {
     color: red;
  }


  .text[data-astro-cid-hhnqfkh6] {
    color: blue;
  }
</style>
```

Scoped styles don‚Äôt leak and won‚Äôt impact the rest of your site. In Astro, it is okay to use low-specificity selectors like h1 {} or p {} because they will be compiled with scopes in the final output.

```
h1 {}
```

```
p {}
```

Scoped styles also won‚Äôt apply to other Astro components contained inside of your template. If you need to style a child component, consider wrapping that component in a <div> (or other element) that you can then style.

```
<div>
```

The specificity of scoped styles is preserved, allowing them to work consistently alongside other CSS files or CSS libraries while still preserving the exclusive boundaries that prevent styles from applying outside the component.

### Global Styles

While we recommend scoped styles for most components, you may eventually find a valid reason to write global, unscoped CSS. You can opt-out of automatic CSS scoping with the <style is:global> attribute.

```
<style is:global>
```

```
<style is:global>
  /* Unscoped, delivered as-is to the browser.
     Applies to all <h1> tags on your site. */
  h1 { color: red; }
</style>
```

```
<style is:global>
  /* Unscoped, delivered as-is to the browser.
     Applies to all <h1> tags on your site. */
  h1 { color: red; }
</style>
```

You can also mix global & scoped CSS rules together in the same <style> tag using the :global() selector. This becomes a powerful pattern for applying CSS styles to children of your component.

```
<style>
```

```
:global()
```

```
<style>
  /* Scoped to this component, only. */
  h1 { color: red; }
  /* Mixed: Applies to child `h1` elements only. */
  article :global(h1) {
    color: blue;
  }
</style>
<h1>Title</h1>
<article><slot /></article>
```

```
<style>
  /* Scoped to this component, only. */
  h1 { color: red; }
  /* Mixed: Applies to child `h1` elements only. */
  article :global(h1) {
    color: blue;
  }
</style>
<h1>Title</h1>
<article><slot /></article>
```

This is a great way to style things like blog posts, or documents with CMS-powered content where the contents live outside of Astro. But be careful: components whose appearance differs based on whether or not they have a certain parent component can become difficult to troubleshoot.

Scoped styles should be used as often as possible. Global styles should be used only as-needed.

### Combining classes with class:list

```
class:list
```

If you need to combine classes on an element dynamically, you can use the class:list utility attribute in .astro files.

```
class:list
```

```
.astro
```

```
---
const { isRed } = Astro.props;
---
<!-- If `isRed` is truthy, class will be "box red". -->
<!-- If `isRed` is falsy, class will be "box". -->
<div class:list={['box', { red: isRed }]}><slot /></div>


<style>
  .box { border: 1px solid blue; }
  .red { border-color: red; }
</style>
```

```
---
const { isRed } = Astro.props;
---
<!-- If `isRed` is truthy, class will be "box red". -->
<!-- If `isRed` is falsy, class will be "box". -->
<div class:list={['box', { red: isRed }]}><slot /></div>


<style>
  .box { border: 1px solid blue; }
  .red { border-color: red; }
</style>
```

```
class:list
```

### CSS Variables

Added in: astro@0.21.0

```
astro@0.21.0
```

The Astro <style> can reference any CSS variables available on the page. You can also pass CSS variables directly from your component frontmatter using the define:vars directive.

```
<style>
```

```
define:vars
```

```
---
const foregroundColor = "rgb(221 243 228)";
const backgroundColor = "rgb(24 121 78)";
---
<style define:vars={{ foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--foregroundColor);
  }
</style>
<h1>Hello</h1>
```

```
---
const foregroundColor = "rgb(221 243 228)";
const backgroundColor = "rgb(24 121 78)";
---
<style define:vars={{ foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--foregroundColor);
  }
</style>
<h1>Hello</h1>
```

```
define:vars
```

### Passing a class to a child component

```
class
```

In Astro, HTML attributes like class do not automatically pass through to child components.

```
class
```

Instead, accept a class prop in the child component and apply it to the root element. When destructuring, you must rename it, because class is a reserved word in JavaScript.

```
class
```

```
class
```

Using the default scoped style strategy, you must also pass the data-astro-cid-* attribute. You can do this by passing the ...rest of the props to the component. If you have changed scopedStyleStrategy to 'class' or 'where', the ...rest prop is not necessary.

```
data-astro-cid-*
```

```
...rest
```

```
scopedStyleStrategy
```

```
'class'
```

```
'where'
```

```
...rest
```

```
---
const { class: className, ...rest } = Astro.props;
---
<div class={className} {...rest}>
  <slot/>
</div>
```

```
---
const { class: className, ...rest } = Astro.props;
---
<div class={className} {...rest}>
  <slot/>
</div>
```

```
---
import MyComponent from "../components/MyComponent.astro"
---
<style>
  .red {
    color: red;
  }
</style>
<MyComponent class="red">This will be red!</MyComponent>
```

```
---
import MyComponent from "../components/MyComponent.astro"
---
<style>
  .red {
    color: red;
  }
</style>
<MyComponent class="red">This will be red!</MyComponent>
```

Scoped styles from parent components

Because the data-astro-cid-* attribute includes the child in its parent‚Äôs scope, it is possible for styles to cascade from parent to child. To avoid this having unintended side effects, ensure you use unique class names in the child component.

```
data-astro-cid-*
```

### Inline styles

You can style HTML elements inline using the style attribute. This can be a CSS string or an object of CSS properties:

```
style
```

```
// These are equivalent:
<p style={{ color: "brown", textDecoration: "underline" }}>My text</p>
<p style="color: brown; text-decoration: underline;">My text</p>
```

```
// These are equivalent:
<p style={{ color: "brown", textDecoration: "underline" }}>My text</p>
<p style="color: brown; text-decoration: underline;">My text</p>
```

## External Styles

There are two ways to resolve external global stylesheets: an ESM import for files located within your project source, and an absolute URL link for files in your public/ directory, or hosted outside of your project.

```
public/
```

```
public/
```

```
src/
```

### Import a local stylesheet

Using an npm package?

You may need to update your astro.config when importing from npm packages. See the ‚Äúimport stylesheets from an npm package‚Äù section below.

```
astro.config
```

You can import stylesheets in your Astro component frontmatter using ESM import syntax. CSS imports work like any other ESM import in an Astro component, which should be referenced as relative to the component and must be written at the top of your component script, with any other imports.

```
---
// Astro will bundle and optimize this CSS for you automatically
// This also works for preprocessor files like .scss, .styl, etc.
import '../styles/utils.css';
---
<html><!-- Your page here --></html>
```

```
---
// Astro will bundle and optimize this CSS for you automatically
// This also works for preprocessor files like .scss, .styl, etc.
import '../styles/utils.css';
---
<html><!-- Your page here --></html>
```

CSS import via ESM are supported inside of any JavaScript file, including JSX components like React & Preact. This can be useful for writing granular, per-component styles for your React components.

```
import
```

### Import a stylesheet from an npm package

You may also need to load stylesheets from an external npm package. This is especially common for utilities like Open Props. If your package recommends using a file extension (i.e. package-name/styles.css instead of package-name/styles), this should work like any local stylesheet:

```
package-name/styles.css
```

```
package-name/styles
```

```
---
import 'package-name/styles.css';
---
<html><!-- Your page here --></html>
```

```
---
import 'package-name/styles.css';
---
<html><!-- Your page here --></html>
```

If your package does not suggest using a file extension (i.e. package-name/styles), you‚Äôll need to update your Astro config first!

```
package-name/styles
```

Say you are importing a CSS file from package-name called normalize (with the file extension omitted). To ensure we can prerender your page correctly, add package-name to the vite.ssr.noExternal array:

```
package-name
```

```
normalize
```

```
package-name
```

```
vite.ssr.noExternal
```

```
import { defineConfig } from 'astro/config';


export default defineConfig({
  vite: {
    ssr: {
      noExternal: ['package-name'],
    }
  }
})
```

```
import { defineConfig } from 'astro/config';


export default defineConfig({
  vite: {
    ssr: {
      noExternal: ['package-name'],
    }
  }
})
```

Note

This is a Vite-specific setting that does not relate to (or require) Astro SSR.

Now, you are free to import package-name/normalize. This will be bundled and optimized by Astro like any other local stylesheet.

```
package-name/normalize
```

```
---
import 'package-name/normalize';
---
<html><!-- Your page here --></html>
```

```
---
import 'package-name/normalize';
---
<html><!-- Your page here --></html>
```

### Load a static stylesheet via ‚Äúlink‚Äù tags

You can also use the <link> element to load a stylesheet on the page. This should be an absolute URL path to a CSS file located in your /public directory, or an URL to an external website. Relative <link> href values are not supported.

```
<link>
```

```
/public
```

```
<link>
```

```
<head>
  <!-- Local: /public/styles/global.css -->
  <link rel="stylesheet" href="/styles/global.css" />
  <!-- External -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css" />
</head>
```

```
<head>
  <!-- Local: /public/styles/global.css -->
  <link rel="stylesheet" href="/styles/global.css" />
  <!-- External -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css" />
</head>
```

Because this approach uses the public/ directory, it skips the normal CSS processing, bundling and optimizations that are provided by Astro. If you need these transformations, use the Import a Stylesheet method above.

```
public/
```

## Cascading Order

Astro components will sometimes have to evaluate multiple sources of CSS. For example, your component might import a CSS stylesheet, include its own <style> tag, and be rendered inside a layout that imports CSS.

```
<style>
```

When conflicting CSS rules apply to the same element, browsers first use specificity and then order of appearance to determine which value to show.

If one rule is more specific than another, no matter where the CSS rule appears, its value will take precedence:

```
<style>
  h1 { color: red }
  div > h1 {
    color: purple
  }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
```

```
<style>
  h1 { color: red }
  div > h1 {
    color: purple
  }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
```

If two rules have the same specificity, then the order of appearance is evaluated, and the last rule‚Äôs value will take precedence:

```
<style>
  h1 { color: purple }
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
```

```
<style>
  h1 { color: purple }
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
```

Astro CSS rules are evaluated in this order of appearance:

- <link> tags in the head (lowest precedence)
```
<link>
```

- imported styles
- scoped styles (highest precedence)
### Scoped Styles

Depending on your chosen value for scopedStyleStrategy, scoped styles may or may not increase the CLASS column specificity.

```
scopedStyleStrategy
```

However, scoped styles will always come last in the order of appearance. These styles will therefore take precedence over other styles of the same specificity. For example, if you import a stylesheet that conflicts with a scoped style, the scoped style‚Äôs value will apply:

```
h1 {
  color: purple;
}
```

```
h1 {
  color: purple;
}
```

```
---
import "./make-it-purple.css"
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
```

```
---
import "./make-it-purple.css"
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
```

Scoped styles will be overwritten if the imported style is more specific. The style with a higher specificity will take precedence over the scoped style:

```
#intro {
  color: purple;
}
```

```
#intro {
  color: purple;
}
```

```
---
import "./make-it-purple.css"
---
<style>
  h1 { color: red }
</style>
<div>
  <h1 id="intro">
    This header will be purple!
  </h1>
</div>
```

```
---
import "./make-it-purple.css"
---
<style>
  h1 { color: red }
</style>
<div>
  <h1 id="intro">
    This header will be purple!
  </h1>
</div>
```

### Import Order

When importing multiple stylesheets in an Astro component, the CSS rules are evaluated in the order that they are imported. A higher specificity will always determine which styles to show, no matter when the CSS is evaluated. But, when conflicting styles have the same specificity, the last one imported wins:

```
div > h1 {
  color: purple;
}
```

```
div > h1 {
  color: purple;
}
```

```
div > h1 {
  color: green;
}
```

```
div > h1 {
  color: green;
}
```

```
---
import "./make-it-green.css"
import "./make-it-purple.css"
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
```

```
---
import "./make-it-green.css"
import "./make-it-purple.css"
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
```

While <style> tags are scoped and only apply to the component that declares them, imported CSS can ‚Äúleak‚Äù. Importing a component applies any CSS it imports, even if the component is never used:

```
<style>
```

```
---
import "./make-it-purple.css"
---
<div>
  <h1>I import purple CSS.</h1>
</div>
```

```
---
import "./make-it-purple.css"
---
<div>
  <h1>I import purple CSS.</h1>
</div>
```

```
---
import "./make-it-green.css"
import PurpleComponent from "./PurpleComponent.astro";
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
```

```
---
import "./make-it-green.css"
import PurpleComponent from "./PurpleComponent.astro";
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
```

Tip

A common pattern in Astro is to import global CSS inside a Layout component. Be sure to import the Layout component before other imports so that it has the lowest precedence.

### Link Tags

Style sheets loaded via link tags are evaluated in order, before any other styles in an Astro file. Therefore, these styles will have lower precedence than imported stylesheets and scoped styles:

```
---
import "../components/make-it-purple.css"
---


<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>Astro</title>
    <link rel="stylesheet" href="/styles/make-it-blue.css" />
  </head>
  <body>
    <div>
      <h1>This will be purple</h1>
    </div>
  </body>
</html>
```

```
---
import "../components/make-it-purple.css"
---


<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>Astro</title>
    <link rel="stylesheet" href="/styles/make-it-blue.css" />
  </head>
  <body>
    <div>
      <h1>This will be purple</h1>
    </div>
  </body>
</html>
```

## Tailwind

Astro comes with support for adding popular CSS libraries, tools, and frameworks to your project like Tailwind and more!

Astro supports both Tailwind 3 and 4. You can add Tailwind 4 support through a Vite plugin to your project with a CLI command, or install legacy dependencies manually to add Tailwind 3 support through an Astro integration.

To upgrade your Astro project from Tailwind 3 to 4 you will need to both add Tailwind 4 support, and remove legacy Tailwind 3 support.

### Add Tailwind 4

In Astro >=5.2.0, use the astro add tailwind command for your package manager to install the official Vite Tailwind plugin. To add Tailwind 4 support to earlier versions of Astro, follow the instructions in the Tailwind docs to add the @tailwindcss/vite Vite plugin manually.

```
>=5.2.0
```

```
astro add tailwind
```

```
@tailwindcss/vite
```

- npm
- pnpm
- Yarn
```
npx astro add tailwind
```

```
npx astro add tailwind
```

```
pnpm astro add tailwind
```

```
pnpm astro add tailwind
```

```
yarn astro add tailwind
```

```
yarn astro add tailwind
```

Then, import tailwindcss into src/styles/global.css (or another CSS file of your choosing) to make Tailwind classes available to your Astro project. This file including the import will be created by default if you used the astro add tailwind command to install the Vite plugin.

```
tailwindcss
```

```
src/styles/global.css
```

```
astro add tailwind
```

```
@import "tailwindcss";
```

```
@import "tailwindcss";
```

Import this file in the pages where you want Tailwind to apply. This is often done in a layout component so that Tailwind styles can be used on all pages sharing that layout:

```
---
import "../styles/global.css";
---
```

```
---
import "../styles/global.css";
---
```

### Upgrade from Tailwind 3

Follow the steps to update an existing Astro project using Tailwind v3 (using the @astrojs/tailwind integration) to Tailwind 4 (using the @tailwindcss/vite plugin).

```
@astrojs/tailwind
```

```
@tailwindcss/vite
```

- Add Tailwind 4 support to your project through the CLI for the latest version of Astro, or by adding the Vite plugin manually.
Add Tailwind 4 support to your project through the CLI for the latest version of Astro, or by adding the Vite plugin manually.

- Uninstall the @astrojs/tailwind integration from your project:

npm
pnpm
Yarn
Terminal window
npm uninstall @astrojs/tailwind
Uninstall the @astrojs/tailwind integration from your project:

```
@astrojs/tailwind
```

- npm
- pnpm
- Yarn
```
npm uninstall @astrojs/tailwind
```

```
npm uninstall @astrojs/tailwind
```

```
pnpm remove @astrojs/tailwind
```

```
pnpm remove @astrojs/tailwind
```

```
yarn remove @astrojs/tailwind
```

```
yarn remove @astrojs/tailwind
```

- Remove the @astrojs/tailwind integration from your astro.config.mjs:

astro.config.mjs
import { defineConfig } from 'astro/config';
import tailwind from '@astrojs/tailwind';


export default defineConfig({
  // ...
  integrations: [tailwind()],
  // ...
});
Remove the @astrojs/tailwind integration from your astro.config.mjs:

```
@astrojs/tailwind
```

```
astro.config.mjs
```

```
import { defineConfig } from 'astro/config';
import tailwind from '@astrojs/tailwind';


export default defineConfig({
  // ...
  integrations: [tailwind()],
  // ...
});
```

```
import { defineConfig } from 'astro/config';
import tailwind from '@astrojs/tailwind';


export default defineConfig({
  // ...
  integrations: [tailwind()],
  // ...
});
```

- Then, upgrade your project according to Tailwind‚Äôs v4 upgrade guide.
Then, upgrade your project according to Tailwind‚Äôs v4 upgrade guide.

### Legacy Tailwind 3 support

To add (or keep) support for Tailwind 3, you will need to have both tailwindcss@3 and the official Astro Tailwind integration @astrojs/tailwind installed. Installing these dependencies manually is only used for legacy Tailwind 3 compatibility, and is not required for Tailwind 4. You will also need a legacy Tailwind configuration:

```
tailwindcss@3
```

```
@astrojs/tailwind
```

- Install Tailwind and the Astro Tailwind integration to your project dependencies using your preferred package manager:

npm
pnpm
Yarn
Terminal window
npm install tailwindcss@3 @astrojs/tailwind
Install Tailwind and the Astro Tailwind integration to your project dependencies using your preferred package manager:

- npm
- pnpm
- Yarn
```
npm install tailwindcss@3 @astrojs/tailwind
```

```
npm install tailwindcss@3 @astrojs/tailwind
```

```
pnpm add tailwindcss@3 @astrojs/tailwind
```

```
pnpm add tailwindcss@3 @astrojs/tailwind
```

```
yarn add tailwindcss@3 @astrojs/tailwind
```

```
yarn add tailwindcss@3 @astrojs/tailwind
```

- Import the integration to your astro.config.mjs file, and add it to your integrations[] array:

astro.config.mjs
import { defineConfig } from 'astro/config';
import tailwind from '@astrojs/tailwind';


export default defineConfig({
  // ...
  integrations: [tailwind()],
  // ...
});
Import the integration to your astro.config.mjs file, and add it to your integrations[] array:

```
astro.config.mjs
```

```
integrations[]
```

```
import { defineConfig } from 'astro/config';
import tailwind from '@astrojs/tailwind';


export default defineConfig({
  // ...
  integrations: [tailwind()],
  // ...
});
```

```
import { defineConfig } from 'astro/config';
import tailwind from '@astrojs/tailwind';


export default defineConfig({
  // ...
  integrations: [tailwind()],
  // ...
});
```

- Create a tailwind.config.mjs file in your project‚Äôs root directory. You can use the following command to generate a basic configuration file for you:

npm
pnpm
Yarn
Terminal window
npx tailwindcss init
Create a tailwind.config.mjs file in your project‚Äôs root directory. You can use the following command to generate a basic configuration file for you:

```
tailwind.config.mjs
```

- npm
- pnpm
- Yarn
```
npx tailwindcss init
```

```
npx tailwindcss init
```

```
pnpm dlx tailwindcss init
```

```
pnpm dlx tailwindcss init
```

```
yarn dlx tailwindcss init
```

```
yarn dlx tailwindcss init
```

- Add the following basic configuration to your tailwind.config.mjs file:

tailwind.config.mjs
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
Add the following basic configuration to your tailwind.config.mjs file:

```
tailwind.config.mjs
```

```
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

```
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

## CSS Preprocessors

Astro supports CSS preprocessors such as Sass, Stylus, and Less through Vite.

### Sass and SCSS

```
npm install sass
```

```
npm install sass
```

Use <style lang="scss"> or <style lang="sass"> in .astro files.

```
<style lang="scss">
```

```
<style lang="sass">
```

```
.astro
```

### Stylus

```
npm install stylus
```

```
npm install stylus
```

Use <style lang="styl"> or <style lang="stylus"> in .astro files.

```
<style lang="styl">
```

```
<style lang="stylus">
```

```
.astro
```

### Less

```
npm install less
```

```
npm install less
```

Use <style lang="less"> in .astro files.

```
<style lang="less">
```

```
.astro
```

### LightningCSS

```
npm install lightningcss
```

```
npm install lightningcss
```

Update your vite configuration in astro.config.mjs:

```
vite
```

```
astro.config.mjs
```

```
import { defineConfig } from 'astro/config'


export default defineConfig({
  vite: {
    css: {
      transformer: "lightningcss",
    },
  },
})
```

```
import { defineConfig } from 'astro/config'


export default defineConfig({
  vite: {
    css: {
      transformer: "lightningcss",
    },
  },
})
```

### In framework components

You can also use all of the above CSS preprocessors within JS frameworks as well! Be sure to follow the patterns each framework recommends:

- React / Preact: import Styles from './styles.module.scss';
```
import Styles from './styles.module.scss';
```

- Vue: <style lang="scss">
```
<style lang="scss">
```

- Svelte: <style lang="scss">
```
<style lang="scss">
```

## PostCSS

Astro comes with PostCSS included as part of Vite. To configure PostCSS for your project, create a postcss.config.cjs file in the project root. You can import plugins using require() after installing them (for example npm install autoprefixer).

```
postcss.config.cjs
```

```
require()
```

```
npm install autoprefixer
```

```
module.exports = {
  plugins: [
    require('autoprefixer'),
    require('cssnano'),
  ],
};
```

```
module.exports = {
  plugins: [
    require('autoprefixer'),
    require('cssnano'),
  ],
};
```

## Frameworks and Libraries

### üìò React / Preact

.jsx files support both global CSS and CSS Modules. To enable the latter, use the .module.css extension (or .module.scss/.module.sass if using Sass).

```
.jsx
```

```
.module.css
```

```
.module.scss
```

```
.module.sass
```

```
import './global.css'; // include global CSS
import Styles from './styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!)
```

```
import './global.css'; // include global CSS
import Styles from './styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!)
```

### üìó Vue

Vue in Astro supports the same methods as vue-loader does:

```
vue-loader
```

- vue-loader - Scoped CSS
- vue-loader - CSS Modules
### üìï Svelte

Svelte in Astro also works exactly as expected: Svelte Styling Docs.

## Markdown Styling

Any Astro styling methods are available to a Markdown layout component, but different methods will have different styling effects on your page.

You can apply global styles to your Markdown content by adding imported stylesheets to the layout that wraps your page content. It is also possible to style your Markdown with <style is:global> tags in the layout component. Note that any styles added are subject to Astro‚Äôs cascading order, and you should check your rendered page carefully to ensure your styles are being applied as intended.

```
<style is:global>
```

You can also add CSS integrations including Tailwind. If you are using Tailwind, the typography plugin can be useful for styling Markdown.

## Production

### Bundle control

When Astro builds your site for production deployment, it minifies and combines your CSS into chunks. Each page on your site gets its own chunk, and additionally, CSS that is shared between multiple pages is further split off into their own chunks for reuse.

However, when you have several pages sharing styles, some shared chunks can become really small. If all of them were sent separately, it would lead to many stylesheets requests and affect site performance. Therefore, by default Astro will link only those in your HTML above 4kB in size as <link rel="stylesheet"> tags, while inlining smaller ones into <style type="text/css">. This approach provides a balance between the number of additional requests and the volume of CSS that can be cached between pages.

```
<link rel="stylesheet">
```

```
<style type="text/css">
```

You can configure the size at which stylesheets will be linked externally (in bytes) using the assetsInlineLimit vite build option. Note that this option affects script and image inlining as well.

```
assetsInlineLimit
```

```
import { defineConfig } from 'astro/config';


export default defineConfig({
  vite: {
    build: {
      assetsInlineLimit: 1024,
    }
  };
});
```

```
import { defineConfig } from 'astro/config';


export default defineConfig({
  vite: {
    build: {
      assetsInlineLimit: 1024,
    }
  };
});
```

If you would rather all project styles remain external, you can configure the inlineStylesheets build option.

```
inlineStylesheets
```

```
import { defineConfig } from 'astro/config';


export default defineConfig({
  build: {
    inlineStylesheets: 'never'
  }
});
```

```
import { defineConfig } from 'astro/config';


export default defineConfig({
  build: {
    inlineStylesheets: 'never'
  }
});
```

You can also set this option to 'always' which will inline all stylesheets.

```
'always'
```

## Advanced

Caution

Be careful when bypassing Astro‚Äôs built-in CSS bundling! Styles won‚Äôt be automatically included in the built output, and it is your responsibility to make sure that the referenced file is properly included in the final page output.

### ?raw CSS Imports

```
?raw
```

For advanced use cases, CSS can be read directly from disk without being bundled or optimized by Astro. This can be useful when you need complete control over some snippet of CSS, and need to bypass Astro‚Äôs automatic CSS handling.

This is not recommended for most users.

```
---
// Advanced example! Not recommended for most users.
import rawStylesCSS from '../styles/main.css?raw';
---
<style is:inline set:html={rawStylesCSS}></style>
```

```
---
// Advanced example! Not recommended for most users.
import rawStylesCSS from '../styles/main.css?raw';
---
<style is:inline set:html={rawStylesCSS}></style>
```

See Vite‚Äôs docs for full details.

### ?url CSS Imports

```
?url
```

For advanced use cases, you can import a direct URL reference for a CSS file inside of your project src/ directory. This can be useful when you need complete control over how a CSS file is loaded on the page. However, this will prevent the optimization of that CSS file with the rest of your page CSS .

```
src/
```

This is not recommended for most users. Instead, place your CSS files inside of public/ to get a consistent URL reference.

```
public/
```

Caution

Importing a smaller CSS file with ?url may return the base64 encoded contents of the CSS file as a data URL in your final build. Either write your code to support encoded data URLs (data:text/css;base64,...) or set the vite.build.assetsInlineLimit config option to 0 to disable this feature.

```
?url
```

```
data:text/css;base64,...
```

```
vite.build.assetsInlineLimit
```

```
0
```

```
---
// Advanced example! Not recommended for most users.
import stylesUrl from '../styles/main.css?url';
---
<link rel="preload" href={stylesUrl} as="style">
<link rel="stylesheet" href={stylesUrl}>
```

```
---
// Advanced example! Not recommended for most users.
import stylesUrl from '../styles/main.css?url';
---
<link rel="preload" href={stylesUrl} as="style">
<link rel="stylesheet" href={stylesUrl}>
```

See Vite‚Äôs docs for full details.

## Learn Astro with Coding in Public

150+ video lessons
			
			‚Ä¢
			Astro v5 ready

