- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
								
							
							
	



						
						
	
				
						Pages
						
					
			
				
						Routing
						
					
			
				
						Endpoints
						
					
			
				
						Middleware
						
					
			
				
						Internationalization (i18n)
						
					
			
				
						Prefetch
						
					
			
				
						View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
								
							
							
	



						
						
	
				
						Components
						
					
			
				
						Layouts
						
					
			
				
						Styles and CSS
						
					
			
				
						Fonts
						
					
			
				
						Syntax Highlighting
						
					
			
				
						Scripts and event handling
						
					
			
				
						Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
								
							
							
	



						
						
	
				
						Markdown
						
					
			
				
						Content collections
						
					
			
				
						Images
						
					
			
				
						Data fetching
						
					
			
				
						Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
								
							
							
	



						
						
	
				
						On-demand rendering
						
					
			
				
						Server islands
						
					
			
				
						Actions
						
					
			
				
						Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
								
							
							
	



						
						
	
				
						Upgrade Astro
						
					
			
				
						
						
							
								Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- Upgrade Astro
- Major upgrade guides
								
							
							
	



						
						
	
				
						v5.0
						
					
			
				
						v4.0
						
					
			
				
						v3.0
						
					
			
				
						v2.0
						
					
			
				
						v1.0
- v5.0
- v4.0
- v3.0
- v2.0
- v1.0
- Troubleshooting
- How-to recipes
								
							
							
	



						
						
	
				
						Recipes overview
						
					
			
				
						Installing a Vite or Rollup plugin
						
					
			
				
						Analyze bundle size
						
					
			
				
						Build a custom image component
						
					
			
				
						Build HTML forms in Astro pages
						
					
			
				
						Build forms with API routes
						
					
			
				
						Use Bun with Astro
						
					
			
				
						Call endpoints from the server
						
					
			
				
						Verify a Captcha
						
					
			
				
						Customize file names in the build output
						
					
			
				
						Build your Astro site with Docker
						
					
			
				
						Dynamically import images
						
					
			
				
						Add icons to external links
						
					
			
				
						Add i18n features
						
					
			
				
						Create a dev toolbar app
						
					
			
				
						Add last modified time
						
					
			
				
						Add reading time
						
					
			
				
						Add an RSS feed
						
					
			
				
						Share state between Astro components
						
					
			
				
						Share state between islands
						
					
			
				
						Using streaming to improve page performance
						
					
			
				
						Style rendered Markdown with Tailwind Typography
- Recipes overview
- Installing a Vite or Rollup plugin
- Analyze bundle size
- Build a custom image component
- Build HTML forms in Astro pages
- Build forms with API routes
- Use Bun with Astro
- Call endpoints from the server
- Verify a Captcha
- Customize file names in the build output
- Build your Astro site with Docker
- Dynamically import images
- Add icons to external links
- Add i18n features
- Create a dev toolbar app
- Add last modified time
- Add reading time
- Add an RSS feed
- Share state between Astro components
- Share state between islands
- Using streaming to improve page performance
- Style rendered Markdown with Tailwind Typography
- Contribute to Astro
- Astro Template Syntax
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
Render context
astro:actions
astro:assets
astro:config
astro:content
astro:env
astro:i18n
astro:middleware
astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
Integration API
Adapter API
Content Loader API
Image Service API
Dev Toolbar App API
Container API (experimental)
Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
Configuring experimental flags
Content Security Policy
Fonts
Live content collections
Client prerendering
Intellisense for collections
Preserve scripts order
Markdown heading ID compatibility
Private meta environment variables inlining
Chrome DevTools workspace
Prerender conflict error
SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- Supported File Types
				
				
	
				
					Files in public/
- Files in public/
- Import statements
				
				
	
				
					JavaScript
				
				
			
				
					TypeScript
				
				
			
				
					NPM Packages
				
				
			
				
					JSON
				
				
			
				
					CSS
				
				
			
				
					CSS Modules
				
				
			
				
					Other Assets
- JavaScript
- TypeScript
- NPM Packages
- JSON
- CSS
- CSS Modules
- Other Assets
- Aliases
- import.meta.glob()
				
				
	
				
					Supported Values
				
				
			
				
					Import type utilities
				
				
			
				
					Glob Patterns
				
				
			
				
					import.meta.glob() vs getCollection()
- Supported Values
- Import type utilities
- Glob Patterns
- import.meta.glob() vs getCollection()
- WASM
- Node Builtins
- Extending file type support
## On this page

- Overview
- Supported File Types
Files in public/
- Files in public/
- Import statements
JavaScript
TypeScript
NPM Packages
JSON
CSS
CSS Modules
Other Assets
- JavaScript
- TypeScript
- NPM Packages
- JSON
- CSS
- CSS Modules
- Other Assets
- Aliases
- import.meta.glob()
Supported Values
Import type utilities
Glob Patterns
import.meta.glob() vs getCollection()
- Supported Values
- Import type utilities
- Glob Patterns
- import.meta.glob() vs getCollection()
- WASM
- Node Builtins
- Extending file type support
## Learn Astro with Coding in Public

150+ video lessons
•
Astro v5 ready

# Imports reference

Astro supports most static assets with zero configuration required. You can use the import statement anywhere in your project JavaScript (including your Astro frontmatter) and Astro will include a built, optimized copy of that static asset in your final build. @import is also supported inside of CSS & <style> tags.

```
import
```

```
@import
```

```
<style>
```

## Supported File Types

The following file types are supported out-of-the-box by Astro:

- Astro Components (.astro)
```
.astro
```

- Markdown (.md, .markdown, etc.)
```
.md
```

```
.markdown
```

- JavaScript (.js, .mjs)
```
.js
```

```
.mjs
```

- TypeScript (.ts)
```
.ts
```

- NPM Packages
- JSON (.json)
```
.json
```

- CSS (.css)
```
.css
```

- CSS Modules (.module.css)
```
.module.css
```

- Images & Assets (.svg, .jpg, .png, etc.)
```
.svg
```

```
.jpg
```

```
.png
```

Additionally, you can extend Astro to add support for different UI Frameworks like React, Svelte and Vue components. You can also install the Astro MDX integration or the Astro Markdoc integration to use .mdx or .mdoc files in your project.

```
.mdx
```

```
.mdoc
```

### Files in public/

```
public/
```

You can place any static asset in the public/ directory of your project, and Astro will copy it directly into your final build untouched. public/ files are not built or bundled by Astro, which means that any type of file is supported.

```
public/
```

```
public/
```

You can reference a public/ file by a URL path directly in your HTML templates.

```
public/
```

```
// To link to /public/reports/annual/2024.pdf
Download the <a href="/reports/annual/2024.pdf">2024 annual statement as a PDF</a>.


// To display /public/assets/cats/ginger.jpg
<img src="/assets/cats/ginger.jpg" alt="An orange cat sleeping on a bed.">
```

```
// To link to /public/reports/annual/2024.pdf
Download the <a href="/reports/annual/2024.pdf">2024 annual statement as a PDF</a>.


// To display /public/assets/cats/ginger.jpg
<img src="/assets/cats/ginger.jpg" alt="An orange cat sleeping on a bed.">
```

## Import statements

Astro uses ESM, the same import and export syntax supported in the browser.

```
import
```

```
export
```

### JavaScript

```
import { getUser } from './user.js';
```

```
import { getUser } from './user.js';
```

JavaScript can be imported using normal ESM import & export syntax.

```
import
```

```
export
```

Importing JSX files

An appropriate UI framework (React, Preact, or Solid) is required to render JSX/TSX files. Use .jsx/.tsx extensions where appropriate, as Astro does not support JSX in .js/.ts files.

```
.jsx
```

```
.tsx
```

```
.js
```

```
.ts
```

### TypeScript

```
import { getUser } from './user';
import type { UserType } from './user';
```

```
import { getUser } from './user';
import type { UserType } from './user';
```

Astro includes built-in support for TypeScript. You can import .ts and .tsx files directly in your Astro project, and even write TypeScript code directly inside your Astro component script and any script tags.

```
.ts
```

```
.tsx
```

Astro doesn’t perform any type checking itself. Type checking should be taken care of outside of Astro, either by your IDE or through a separate script. For type checking Astro files, the astro check command is provided.

```
astro check
```

TypeScript and file extensions

Per TypeScript’s module resolution rules, .ts and .tsx file extensions should not be used when importing TypeScript files. Instead, either use .js/.jsx file extensions or completely omit the file extension.

```
.ts
```

```
.tsx
```

```
.js
```

```
.jsx
```

```
import { getUser } from './user.js'; // user.ts
import MyComponent from "./MyComponent"; // MyComponent.tsx
```

```
import { getUser } from './user.js'; // user.ts
import MyComponent from "./MyComponent"; // MyComponent.tsx
```

### NPM Packages

If you’ve installed an NPM package, you can import it in Astro.

```
---
import { Icon } from 'astro-icon';
---
```

```
---
import { Icon } from 'astro-icon';
---
```

If a package was published using a legacy format, Astro will try to convert the package to ESM so that import statements work. In some cases, you may need to adjust your vite config for it to work.

```
import
```

```
vite
```

Caution

Some packages rely on a browser environment. Astro components runs on the server, so importing these packages in the frontmatter may lead to errors.

### JSON

```
// Load the JSON object via the default export
import json from './data.json';
```

```
// Load the JSON object via the default export
import json from './data.json';
```

Astro supports importing JSON files directly into your application. Imported files return the full JSON object in the default import.

### CSS

```
// Load and inject 'style.css' onto the page
import './style.css';
```

```
// Load and inject 'style.css' onto the page
import './style.css';
```

Astro supports importing CSS files directly into your application. Imported styles expose no exports, but importing one will automatically add those styles to the page. This works for all CSS files by default, and can support compile-to-CSS languages like Sass & Less via plugins.

### CSS Modules

```
// 1. Converts './style.module.css' classnames to unique, scoped values.
// 2. Returns an object mapping the original classnames to their final, scoped value.
import styles from './style.module.css';


// This example uses JSX, but you can use CSS Modules with any framework.
return <div className={styles.error}>Your Error Message</div>;
```

```
// 1. Converts './style.module.css' classnames to unique, scoped values.
// 2. Returns an object mapping the original classnames to their final, scoped value.
import styles from './style.module.css';


// This example uses JSX, but you can use CSS Modules with any framework.
return <div className={styles.error}>Your Error Message</div>;
```

Astro supports CSS Modules using the [name].module.css naming convention. Like any CSS file, importing one will automatically apply that CSS to the page. However, CSS Modules export a special default styles object that maps your original classnames to unique identifiers.

```
[name].module.css
```

```
styles
```

CSS Modules help you enforce component scoping & isolation on the frontend with uniquely-generated class names for your stylesheets.

### Other Assets

```
// Returns an object with `src` and other properties
import imgReference from './image.png';
import svgReference from './image.svg';


// HTML or UI Framework components use this to render the image
<img src={imgReference.src} alt="image description" />;


// The Astro `<Image />` and `<Picture />` components access `src` by default
<Image src={imgReference} alt="image description">
```

```
// Returns an object with `src` and other properties
import imgReference from './image.png';
import svgReference from './image.svg';


// HTML or UI Framework components use this to render the image
<img src={imgReference.src} alt="image description" />;


// The Astro `<Image />` and `<Picture />` components access `src` by default
<Image src={imgReference} alt="image description">
```

All other assets not explicitly mentioned above can be imported via ESM import and will return a URL reference to the final built asset (e.g. /_astro/my-video.C7vXpQtF.mp4) instead of an object.

```
import
```

```
/_astro/my-video.C7vXpQtF.mp4
```

This can be useful for referencing non-JS assets by URL, like creating a video element with a src attribute pointing to that image.

```
src
```

It can also be useful to place images and other assets in the public/ folder as explained on the project-structure page.

```
public/
```

```
?url
```

```
?raw
```

Note

Adding alt text to <img> tags is encouraged for accessibility! Don’t forget to add an alt="a helpful description" attribute to your image elements. You can just leave the attribute empty if the image is purely decorative.

```
<img>
```

```
alt="a helpful description"
```

## Aliases

An alias is a way to create shortcuts for your imports.

Aliases can help improve the development experience in codebases with many directories or relative imports.

```
---
import Button from '../../components/controls/Button.astro';
import logoUrl from '../../assets/logo.png?url';
---
```

```
---
import Button from '../../components/controls/Button.astro';
import logoUrl from '../../assets/logo.png?url';
---
```

In this example, a developer would need to understand the tree relationship between src/pages/about/company.astro, src/components/controls/Button.astro, and src/assets/logo.png. And then, if the company.astro file were to be moved, these imports would also need to be updated.

```
src/pages/about/company.astro
```

```
src/components/controls/Button.astro
```

```
src/assets/logo.png
```

```
company.astro
```

You can add import aliases in tsconfig.json.

```
tsconfig.json
```

```
{
  "compilerOptions": {
    "paths": {
      "@components/*": ["./src/components/*"],
      "@assets/*": ["./src/assets/*"]
    }
  }
}
```

```
{
  "compilerOptions": {
    "paths": {
      "@components/*": ["./src/components/*"],
      "@assets/*": ["./src/assets/*"]
    }
  }
}
```

The development server will automatically restart after this configuration change. You can now import using the aliases anywhere in your project:

```
---
import Button from '@components/controls/Button.astro';
import logoUrl from '@assets/logo.png?url';
---
```

```
---
import Button from '@components/controls/Button.astro';
import logoUrl from '@assets/logo.png?url';
---
```

## import.meta.glob()

```
import.meta.glob()
```

Vite’s import.meta.glob() is a way to import many files at once using glob patterns to find matching file paths.

```
import.meta.glob()
```

import.meta.glob() takes a relative glob pattern matching the local files you’d like to import as a parameter. It returns an array of each matching file’s exports. To load all matched modules up front, pass { eager: true } as the second argument:

```
import.meta.glob()
```

```
{ eager: true }
```

```
---
// imports all files that end with `.md` in `./src/pages/post/`
const matches = import.meta.glob('../pages/post/*.md', { eager: true });
const posts = Object.values(matches);
---
<!-- Renders an <article> for the first 5 blog posts -->
<div>
{posts.slice(0, 4).map((post) => (
  <article>
    <h2>{post.frontmatter.title}</h2>
    <p>{post.frontmatter.description}</p>
    <a href={post.url}>Read more</a>
  </article>
))}
</div>
```

```
---
// imports all files that end with `.md` in `./src/pages/post/`
const matches = import.meta.glob('../pages/post/*.md', { eager: true });
const posts = Object.values(matches);
---
<!-- Renders an <article> for the first 5 blog posts -->
<div>
{posts.slice(0, 4).map((post) => (
  <article>
    <h2>{post.frontmatter.title}</h2>
    <p>{post.frontmatter.description}</p>
    <a href={post.url}>Read more</a>
  </article>
))}
</div>
```

Astro components imported using import.meta.glob are of type AstroInstance. You can render each component instance using its default property:

```
import.meta.glob
```

```
AstroInstance
```

```
default
```

```
---
// imports all files that end with `.astro` in `./src/components/`
const components = Object.values(import.meta.glob('../components/*.astro', { eager: true }));
---
<!-- Display all of our components -->
{components.map((component) => (
  <div>
    <component.default size={24} />
  </div>
))}
```

```
---
// imports all files that end with `.astro` in `./src/components/`
const components = Object.values(import.meta.glob('../components/*.astro', { eager: true }));
---
<!-- Display all of our components -->
{components.map((component) => (
  <div>
    <component.default size={24} />
  </div>
))}
```

### Supported Values

Vite’s import.meta.glob() function only supports static string literals. It does not support dynamic variables and string interpolation.

```
import.meta.glob()
```

A common workaround is to instead import a larger set of files that includes all the files you need, then filter them:

```
---
const { postSlug } = Astro.props;
const pathToMyFeaturedPost = `src/pages/blog/${postSlug}.md`;


const posts = Object.values(import.meta.glob("../pages/blog/*.md", { eager: true }));
const myFeaturedPost = posts.find(post => post.file.includes(pathToMyFeaturedPost));
---


<p>
  Take a look at my favorite post, <a href={myFeaturedPost.url}>{myFeaturedPost.frontmatter.title}</a>!
</p>
```

```
---
const { postSlug } = Astro.props;
const pathToMyFeaturedPost = `src/pages/blog/${postSlug}.md`;


const posts = Object.values(import.meta.glob("../pages/blog/*.md", { eager: true }));
const myFeaturedPost = posts.find(post => post.file.includes(pathToMyFeaturedPost));
---


<p>
  Take a look at my favorite post, <a href={myFeaturedPost.url}>{myFeaturedPost.frontmatter.title}</a>!
</p>
```

### Import type utilities

#### Markdown files

Markdown files loaded with import.meta.glob() return the following MarkdownInstance interface:

```
import.meta.glob()
```

```
MarkdownInstance
```

```
export interface MarkdownInstance<T extends Record<string, any>> {
  /* Any data specified in this file's YAML/TOML frontmatter */
  frontmatter: T;
  /* The absolute file path of this file */
  file: string;
  /* The rendered path of this file */
  url: string | undefined;
  /* Astro Component that renders the contents of this file */
  Content: AstroComponentFactory;
  /** (Markdown only) Raw Markdown file content, excluding layout HTML and YAML/TOML frontmatter */
  rawContent(): string;
  /** (Markdown only) Markdown file compiled to HTML, excluding layout HTML */
  compiledContent(): string;
  /* Function that returns an array of the h1...h6 elements in this file */
  getHeadings(): Promise<{ depth: number; slug: string; text: string }[]>;
  default: AstroComponentFactory;
}
```

```
export interface MarkdownInstance<T extends Record<string, any>> {
  /* Any data specified in this file's YAML/TOML frontmatter */
  frontmatter: T;
  /* The absolute file path of this file */
  file: string;
  /* The rendered path of this file */
  url: string | undefined;
  /* Astro Component that renders the contents of this file */
  Content: AstroComponentFactory;
  /** (Markdown only) Raw Markdown file content, excluding layout HTML and YAML/TOML frontmatter */
  rawContent(): string;
  /** (Markdown only) Markdown file compiled to HTML, excluding layout HTML */
  compiledContent(): string;
  /* Function that returns an array of the h1...h6 elements in this file */
  getHeadings(): Promise<{ depth: number; slug: string; text: string }[]>;
  default: AstroComponentFactory;
}
```

You can optionally provide a type for the frontmatter variable using a TypeScript generic.

```
frontmatter
```

```
---
import type { MarkdownInstance } from 'astro';
interface Frontmatter {
    title: string;
    description?: string;
}


const posts = Object.values(import.meta.glob<MarkdownInstance<Frontmatter>>('./posts/**/*.md', { eager: true }));
---


<ul>
  {posts.map(post => <li>{post.frontmatter.title}</li>)}
</ul>
```

```
---
import type { MarkdownInstance } from 'astro';
interface Frontmatter {
    title: string;
    description?: string;
}


const posts = Object.values(import.meta.glob<MarkdownInstance<Frontmatter>>('./posts/**/*.md', { eager: true }));
---


<ul>
  {posts.map(post => <li>{post.frontmatter.title}</li>)}
</ul>
```

#### Astro files

Astro files have the following interface:

```
export interface AstroInstance {
  /* The file path of this file */
  file: string;
  /* The URL for this file (if it is in the pages directory) */
  url: string | undefined;
  default: AstroComponentFactory;
}
```

```
export interface AstroInstance {
  /* The file path of this file */
  file: string;
  /* The URL for this file (if it is in the pages directory) */
  url: string | undefined;
  default: AstroComponentFactory;
}
```

#### Other files

Other files may have various different interfaces, but import.meta.glob() accepts a TypeScript generic if you know exactly what an unrecognized file type contains.

```
import.meta.glob()
```

```
---
interface CustomDataFile {
  default: Record<string, any>;
}
const data = import.meta.glob<CustomDataFile>('../data/**/*.js');
---
```

```
---
interface CustomDataFile {
  default: Record<string, any>;
}
const data = import.meta.glob<CustomDataFile>('../data/**/*.js');
---
```

### Glob Patterns

A glob pattern is a file path that supports special wildcard characters. This is used to reference multiple files in your project at once.

For example, the glob pattern ./pages/**/*.{md,mdx} starts within the pages subdirectory, looks through all of its subdirectories (/**), and matches any filename (/*) that ends in either .md or .mdx (.{md,mdx}).

```
./pages/**/*.{md,mdx}
```

```
/**
```

```
/*
```

```
.md
```

```
.mdx
```

```
.{md,mdx}
```

#### Glob Patterns in Astro

To use with import.meta.glob(), the glob pattern must be a string literal and cannot contain any variables.

```
import.meta.glob()
```

Additionally, glob patterns must begin with one of the following:

- ./ (to start in the current directory)
```
./
```

- ../ (to start in the parent directory)
```
../
```

- / (to start at the root of the project)
```
/
```

Read more about the glob pattern syntax.

### import.meta.glob() vs getCollection()

```
import.meta.glob()
```

```
getCollection()
```

Content collections provide a getCollection() API for loading multiple files instead of import.meta.glob(). If your content files (e.g. Markdown, MDX, Markdoc) are located in collections within the src/content/ directory, use getCollection() to query a collection and return content entries.

```
getCollection()
```

```
import.meta.glob()
```

```
src/content/
```

```
getCollection()
```

## WASM

```
// Loads and initializes the requested WASM file
const wasm = await WebAssembly.instantiateStreaming(fetch('/example.wasm'));
```

```
// Loads and initializes the requested WASM file
const wasm = await WebAssembly.instantiateStreaming(fetch('/example.wasm'));
```

Astro supports loading WASM files directly into your application using the browser’s WebAssembly API.

```
WebAssembly
```

## Node Builtins

Astro supports Node.js built-ins, with some limitations, using Node’s newer node: prefix. There may be differences between development and production, and some features may be incompatible with on-demand rendering. Some adapters may also be incompatible with these built-ins modules or require configuration to support a subset (e.g., Cloudflare Workers or Deno).

```
node:
```

The following example imports the util module from Node to parse a media type (MIME):

```
util
```

```
---
// Example: import the "util" built-in from Node.js
import util from 'node:util';


export interface Props {
  mimeType: string,
}


const mime = new util.MIMEType(Astro.props.mimeType)
---


<span>Type: {mime.type}</span>
<span>SubType: {mime.subtype}</span>
```

```
---
// Example: import the "util" built-in from Node.js
import util from 'node:util';


export interface Props {
  mimeType: string,
}


const mime = new util.MIMEType(Astro.props.mimeType)
---


<span>Type: {mime.type}</span>
<span>SubType: {mime.subtype}</span>
```

## Extending file type support

With Vite and compatible Rollup plugins, you can import file types which aren’t natively supported by Astro. Learn where to find the plugins you need in the Finding Plugins section of the Vite Documentation.

Plugin configuration

Refer to your plugin’s documentation for configuration options, and how to correctly install it.

## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

