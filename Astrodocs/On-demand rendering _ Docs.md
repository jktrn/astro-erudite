- Start
- Guides and recipes
- Reference
- Integrations
- Third-party services
- Getting started
- Welcome, world!
								
							
							
	



						
						
	
				
						Why Astro?
						
					
			
				
						Islands architecture
						
					
			
				
						Tutorial: Build a blog
						
					
			
				
						Courses
- Why Astro?
- Islands architecture
- Tutorial: Build a blog
- Courses
- Start a new project
								
							
							
	



						
						
	
				
						Installation
						
					
			
				
						Project structure
						
					
			
				
						Develop and build
- Installation
- Project structure
- Develop and build
- Configuration
								
							
							
	



						
						
	
				
						Configuration overview
						
					
			
				
						Editor setup
						
					
			
				
						TypeScript
						
					
			
				
						Environment variables
						
					
			
				
						Build with AI
						
					
			
				
						Dev toolbar
- Configuration overview
- Editor setup
- TypeScript
- Environment variables
- Build with AI
- Dev toolbar
- Migrate to Astro
								
							
							
	



						
						
	
				
						Site migration overview
						
					
			
				
						Create React App
						
					
			
				
						Docusaurus
						
					
			
				
						Eleventy
						
					
			
				
						Gatsby
						
					
			
				
						GitBook
						
					
			
				
						Gridsome
						
					
			
				
						Hugo
						
					
			
				
						Jekyll
						
					
			
				
						Next.js
						
					
			
				
						NuxtJS
						
					
			
				
						Pelican
						
					
			
				
						SvelteKit
						
					
			
				
						VuePress
						
					
			
				
						WordPress
- Site migration overview
- Create React App
- Docusaurus
- Eleventy
- Gatsby
- GitBook
- Gridsome
- Hugo
- Jekyll
- Next.js
- NuxtJS
- Pelican
- SvelteKit
- VuePress
- WordPress
- Routing and navigation
Pages
Routing
Endpoints
Middleware
Internationalization (i18n)
Prefetch
View transitions
- Pages
- Routing
- Endpoints
- Middleware
- Internationalization (i18n)
- Prefetch
- View transitions
- Build your UI
Components
Layouts
Styles and CSS
Fonts
Syntax Highlighting
Scripts and event handling
Front-end frameworks
- Components
- Layouts
- Styles and CSS
- Fonts
- Syntax Highlighting
- Scripts and event handling
- Front-end frameworks
- Add content to your site
Markdown
Content collections
Images
Data fetching
Astro DB
- Markdown
- Content collections
- Images
- Data fetching
- Astro DB
- Server rendering
On-demand rendering
Server islands
Actions
Sessions
- On-demand rendering
- Server islands
- Actions
- Sessions
- Upgrade
Upgrade Astro
Major upgrade guides
- Upgrade Astro
- Major upgrade guides
- Troubleshooting
- How-to recipes
- Contribute to Astro
- Astro Template Syntax
								
							
							
	



						
						
	
				
						Template expressions reference
						
					
			
				
						Template directives reference
- Template expressions reference
- Template directives reference
- Configuration Reference
- CLI Commands
- Imports reference
- Routing Reference
- Runtime API
								
							
							
	



						
						
	
				
						Render context
						
					
			
				
						astro:actions
						
					
			
				
						astro:assets
						
					
			
				
						astro:config
						
					
			
				
						astro:content
						
					
			
				
						astro:env
						
					
			
				
						astro:i18n
						
					
			
				
						astro:middleware
						
					
			
				
						astro:transitions
- Render context
- astro:actions
- astro:assets
- astro:config
- astro:content
- astro:env
- astro:i18n
- astro:middleware
- astro:transitions
- Other development APIs
								
							
							
	



						
						
	
				
						Integration API
						
					
			
				
						Adapter API
						
					
			
				
						Content Loader API
						
					
			
				
						Image Service API
						
					
			
				
						Dev Toolbar App API
						
					
			
				
						Container API (experimental)
						
					
			
				
						Programmatic Astro API (experimental)
- Integration API
- Adapter API
- Content Loader API
- Image Service API
- Dev Toolbar App API
- Container API (experimental)
- Programmatic Astro API (experimental)
- Experimental features
								
							
							
	



						
						
	
				
						Configuring experimental flags
						
					
			
				
						Content Security Policy
						
					
			
				
						Fonts
						
					
			
				
						Live content collections
						
					
			
				
						Client prerendering
						
					
			
				
						Intellisense for collections
						
					
			
				
						Preserve scripts order
						
					
			
				
						Markdown heading ID compatibility
						
					
			
				
						Private meta environment variables inlining
						
					
			
				
						Chrome DevTools workspace
						
					
			
				
						Prerender conflict error
						
					
			
				
						SVG optimization
- Configuring experimental flags
- Content Security Policy
- Fonts
- Live content collections
- Client prerendering
- Intellisense for collections
- Preserve scripts order
- Markdown heading ID compatibility
- Private meta environment variables inlining
- Chrome DevTools workspace
- Prerender conflict error
- SVG optimization
- Legacy flags
- Error reference
- Integrations overview
- UI frameworks
								
							
							
	



						
						
	
				
						Alpine.js
						
					
			
				
						Preact
						
					
			
				
						React
						
					
			
				
						SolidJS
						
					
			
				
						Svelte
						
					
			
				
						Vue
- Alpine.js
- Preact
- React
- SolidJS
- Svelte
- Vue
- Adapters
								
							
							
	



						
						
	
				
						Cloudflare
						
					
			
				
						Netlify
						
					
			
				
						Node
						
					
			
				
						Vercel
- Cloudflare
- Netlify
- Node
- Vercel
- Other official integrations
								
							
							
	



						
						
	
				
						DB
						
					
			
				
						Markdoc
						
					
			
				
						MDX
						
					
			
				
						Partytown
						
					
			
				
						Sitemap
- DB
- Markdoc
- MDX
- Partytown
- Sitemap
- Publish to npm
- Deployment guides
								
							
							
	



						
						
	
				
						Deployment overview
						
					
			
				
						AWS
						
					
			
				
						AWS via Flightcontrol
						
					
			
				
						AWS via SST
						
					
			
				
						Azion
						
					
			
				
						Buddy
						
					
			
				
						Cleavr
						
					
			
				
						Clever Cloud
						
					
			
				
						Cloudflare
						
					
			
				
						CloudRay
						
					
			
				
						Deno Deploy
						
					
			
				
						DeployHQ
						
					
			
				
						Firebase
						
					
			
				
						Fleek
						
					
			
				
						Fly.io
						
					
			
				
						GitHub Pages
						
					
			
				
						GitLab Pages
						
					
			
				
						Google Cloud
						
					
			
				
						Heroku
						
					
			
				
						Juno
						
					
			
				
						Kinsta
						
					
			
				
						Microsoft Azure
						
					
			
				
						Netlify
						
					
			
				
						Railway
						
					
			
				
						Render
						
					
			
				
						Seenode
						
					
			
				
						Stormkit
						
					
			
				
						Surge
						
					
			
				
						Vercel
						
					
			
				
						Zeabur
						
					
			
				
						Zephyr Cloud
						
					
			
				
						Zerops
- Deployment overview
- AWS
- AWS via Flightcontrol
- AWS via SST
- Azion
- Buddy
- Cleavr
- Clever Cloud
- Cloudflare
- CloudRay
- Deno Deploy
- DeployHQ
- Firebase
- Fleek
- Fly.io
- GitHub Pages
- GitLab Pages
- Google Cloud
- Heroku
- Juno
- Kinsta
- Microsoft Azure
- Netlify
- Railway
- Render
- Seenode
- Stormkit
- Surge
- Vercel
- Zeabur
- Zephyr Cloud
- Zerops
- Content management systems
								
							
							
	



						
						
	
				
						CMS overview
						
					
			
				
						ApostropheCMS
						
					
			
				
						Builder.io
						
					
			
				
						ButterCMS
						
					
			
				
						Caisy
						
					
			
				
						CloudCannon
						
					
			
				
						Contentful
						
					
			
				
						Cosmic
						
					
			
				
						Craft CMS
						
					
			
				
						Craft Cross CMS
						
					
			
				
						Crystallize
						
					
			
				
						DatoCMS
						
					
			
				
						Decap CMS
						
					
			
				
						Directus
						
					
			
				
						Drupal
						
					
			
				
						Flotiq
						
					
			
				
						Front Matter CMS
						
					
			
				
						Ghost
						
					
			
				
						GitCMS
						
					
			
				
						Hashnode
						
					
			
				
						Hygraph
						
					
			
				
						JekyllPad
						
					
			
				
						Keystatic
						
					
			
				
						KeystoneJS
						
					
			
				
						Kontent.ai
						
					
			
				
						microCMS
						
					
			
				
						Optimizely CMS
						
					
			
				
						Payload CMS
						
					
			
				
						Prepr CMS
						
					
			
				
						Prismic
						
					
			
				
						Sanity
						
					
			
				
						Sitecore XM
						
					
			
				
						Sitepins
						
					
			
				
						Spinal
						
					
			
				
						Statamic
						
					
			
				
						Storyblok
						
					
			
				
						Strapi
						
					
			
				
						StudioCMS
						
					
			
				
						Tina CMS
						
					
			
				
						Umbraco
						
					
			
				
						Wordpress
- CMS overview
- ApostropheCMS
- Builder.io
- ButterCMS
- Caisy
- CloudCannon
- Contentful
- Cosmic
- Craft CMS
- Craft Cross CMS
- Crystallize
- DatoCMS
- Decap CMS
- Directus
- Drupal
- Flotiq
- Front Matter CMS
- Ghost
- GitCMS
- Hashnode
- Hygraph
- JekyllPad
- Keystatic
- KeystoneJS
- Kontent.ai
- microCMS
- Optimizely CMS
- Payload CMS
- Prepr CMS
- Prismic
- Sanity
- Sitecore XM
- Sitepins
- Spinal
- Statamic
- Storyblok
- Strapi
- StudioCMS
- Tina CMS
- Umbraco
- Wordpress
- Backend services
								
							
							
	



						
						
	
				
						Backend services overview
						
					
			
				
						Appwrite
						
					
			
				
						Firebase
						
					
			
				
						Neon
						
					
			
				
						Prisma Postgres
						
					
			
				
						Sentry
						
					
			
				
						Supabase
						
					
			
				
						Turso
						
					
			
				
						Xata
- Backend services overview
- Appwrite
- Firebase
- Neon
- Prisma Postgres
- Sentry
- Supabase
- Turso
- Xata
- Image and video hosting
								
							
							
	



						
						
	
				
						Media hosting overview
						
					
			
				
						Cloudinary
						
					
			
				
						Mux
- Media hosting overview
- Cloudinary
- Mux
- E-commerce
- Authentication
- Testing
## Sponsored by

## Sponsored by

- Overview
- Server adapters
				
				
	
				
					Add an Adapter
- Add an Adapter
- Enabling on-demand rendering
				
				
	
				
					'server' mode
- 'server' mode
- On-demand rendering features
				
				
	
				
					HTML streaming
				
				
			
				
					Cookies
				
				
			
				
					Response
				
				
			
				
					Request
				
				
			
				
					Server Endpoints
- HTML streaming
- Cookies
- Response
- Request
- Server Endpoints
## On this page

- Overview
- Server adapters
Add an Adapter
- Add an Adapter
- Enabling on-demand rendering
'server' mode
- 'server' mode
- On-demand rendering features
HTML streaming
Cookies
Response
Request
Server Endpoints
- HTML streaming
- Cookies
- Response
- Request
- Server Endpoints
## Learn Astro with Coding in Public

150+ video lessons
•
Astro v5 ready

# On-demand rendering

Your Astro project code must be rendered to HTML in order to be displayed on the web.

By default, Astro pages, routes, and API endpoints will be pre-rendered at build time as static pages. However, you can choose to render some or all of your routes on demand by a server when a route is requested.

On-demand rendered pages and routes are generated per visit, and can be customized for each viewer. For example, a page rendered on demand can show a logged-in user their account information or display freshly updated data without requiring a full-site rebuild.

On-demand rendering on the server at request time is also known as server-side rendering (SSR).

## Server adapters

To render any page on demand, you need to add an adapter. Each adapter allows Astro to output a script that runs your project on a specific runtime: the environment that runs code on the server to generate pages when they are requested (e.g. Netlify, Cloudflare).

You may also wish to add an adapter even if your site is entirely static and you are not rendering any pages on demand. For example, the Netlify adapter enables Netlify’s Image CDN, and server islands require an adapter installed to use server:defer on a component.

```
server:defer
```

### Adapters

- @astrojs/cloudflare
### @astrojs/cloudflare

- @astrojs/netlify
### @astrojs/netlify

- @astrojs/node
### @astrojs/node

- @astrojs/vercel
### @astrojs/vercel

Astro maintains official adapters for Node.js, Netlify, Vercel, and Cloudflare. You can find both official and community adapters in our integrations directory. Choose the one that corresponds to your deployment environment.

### Add an Adapter

You can add any of the official adapter integrations maintained by Astro with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.

```
astro add
```

```
astro.config.mjs
```

For example, to install the Netlify adapter, run:

- npm
- pnpm
- Yarn
```
npx astro add netlify
```

```
npx astro add netlify
```

```
pnpm astro add netlify
```

```
pnpm astro add netlify
```

```
yarn astro add netlify
```

```
yarn astro add netlify
```

You can also add an adapter manually by installing the NPM package (e.g. @astrojs/netlify) and updating astro.config.mjs yourself.

```
@astrojs/netlify
```

```
astro.config.mjs
```

Note that different adapters may have different configuration settings. Read each adapter’s documentation, and apply any necessary config options to your chosen adapter in astro.config.mjs

```
astro.config.mjs
```

## Enabling on-demand rendering

By default, your entire Astro site will be prerendered, and static HTML pages will be sent to the browser. However, you may opt out of prerendering on any routes that require server rendering, for example, a page that checks for cookies and displays personalized content.

First, add an adapter integration for your server runtime to enable on-demand server rendering in your Astro project.

Then, add export const prerender = false at the top of the individual page or endpoint you want to render on demand. The rest of your site will remain a static site:

```
export const prerender = false
```

```
---
export const prerender = false
---
<html>
<!--
This content will be server-rendered on demand!
Just add an adapter integration for a server runtime!
All other pages are statically-generated at build time!
-->
<html>
```

```
---
export const prerender = false
---
<html>
<!--
This content will be server-rendered on demand!
Just add an adapter integration for a server runtime!
All other pages are statically-generated at build time!
-->
<html>
```

The following example shows opting out of prerendering in order to display a random number each time the endpoint is hit:

```
export const prerender = false;


export async function GET() {
  let number = Math.random();
  return new Response(
    JSON.stringify({
      number,
      message: `Here's a random number: ${number}`,
    }),
  );
}
```

```
export const prerender = false;


export async function GET() {
  let number = Math.random();
  return new Response(
    JSON.stringify({
      number,
      message: `Here's a random number: ${number}`,
    }),
  );
}
```

### 'server' mode

```
'server'
```

For a highly dynamic app, after adding an adapter, you can set your build output configuration to output: 'server' to server-render all your pages by default. This is the equivalent of opting out of prerendering on every page.

```
output: 'server'
```

Then, if needed, you can choose to prerender any individual pages that do not require a server to execute, such as a privacy policy or about page.

```
---
export const prerender = true
---
<html>
<!--
`output: 'server'` is configured, but this page is static!
The rest of my site is rendered on demand!
-->
<html>
```

```
---
export const prerender = true
---
<html>
<!--
`output: 'server'` is configured, but this page is static!
The rest of my site is rendered on demand!
-->
<html>
```

Add export const prerender = true to any page or route to prerender a static page or endpoint:

```
export const prerender = true
```

```
export const prerender = true;


export async function GET() {
  return new Response(
    JSON.stringify({
      message: `This is my static endpoint`,
    }),
  );
}
```

```
export const prerender = true;


export async function GET() {
  return new Response(
    JSON.stringify({
      message: `This is my static endpoint`,
    }),
  );
}
```

Tip

Start with the default 'static' mode until you are sure that most or all of your pages will be rendered on demand! This ensures that your site is as performant as possible, not relying on a server function to render static content.

```
'static'
```

The 'server' output mode does not bring any additional functionality. It only switches the default rendering behavior.

```
'server'
```

```
output
```

## On-demand rendering features

### HTML streaming

With HTML streaming, a document is broken up into chunks, sent over the network in order, and rendered on the page in that order. Astro uses HTML streaming in on-demand rendering to send each component to the browser as it renders them. This makes sure the user sees your HTML as fast as possible, although network conditions can cause large documents to be downloaded slowly, and waiting for data fetches can block page rendering.

Caution

Features that modify the Response headers are only available at the page level. (You can’t use them inside of components, including layout components.) By the time Astro runs your component code, it has already sent the Response headers and they cannot be modified.

### Cookies

A page or API endpoint rendered on demand can check, set, get, and delete cookies.

The example below updates the value of a cookie for a page view counter:

```
---
export const prerender = false; // Not needed in 'server' mode


let counter = 0


if (Astro.cookies.has('counter')) {
  const cookie = Astro.cookies.get('counter')
  const value = cookie?.number()
  if (value !== undefined && !isNaN(value)) counter = value + 1
}


Astro.cookies.set('counter', String(counter))
---
<html>
  <h1>Counter = {counter}</h1>
</html>
```

```
---
export const prerender = false; // Not needed in 'server' mode


let counter = 0


if (Astro.cookies.has('counter')) {
  const cookie = Astro.cookies.get('counter')
  const value = cookie?.number()
  if (value !== undefined && !isNaN(value)) counter = value + 1
}


Astro.cookies.set('counter', String(counter))
---
<html>
  <h1>Counter = {counter}</h1>
</html>
```

See more details about Astro.cookies and the AstroCookie type in the API reference.

```
Astro.cookies
```

```
AstroCookie
```

### Response

```
Response
```

Astro.response is a standard ResponseInit object. It can be used to set the response status and headers.

```
Astro.response
```

```
ResponseInit
```

The example below sets a response status and status text for a product page when the product does not exist:

```
---
export const prerender = false; // Not needed in 'server' mode


import { getProduct } from '../api';


const product = await getProduct(Astro.params.id);


// No product found
if (!product) {
  Astro.response.status = 404;
  Astro.response.statusText = 'Not found';
}
---
<html>
  <!-- Page here... -->
</html>
```

```
---
export const prerender = false; // Not needed in 'server' mode


import { getProduct } from '../api';


const product = await getProduct(Astro.params.id);


// No product found
if (!product) {
  Astro.response.status = 404;
  Astro.response.statusText = 'Not found';
}
---
<html>
  <!-- Page here... -->
</html>
```

#### Astro.response.headers

```
Astro.response.headers
```

You can set headers using the Astro.response.headers object:

```
Astro.response.headers
```

```
---
export const prerender = false; // Not needed in 'server' mode


Astro.response.headers.set('Cache-Control', 'public, max-age=3600');
---
<html>
  <!-- Page here... -->
</html>
```

```
---
export const prerender = false; // Not needed in 'server' mode


Astro.response.headers.set('Cache-Control', 'public, max-age=3600');
---
<html>
  <!-- Page here... -->
</html>
```

#### Return a Response object

```
Response
```

You can also return a Response object directly from any page using on-demand rendering either manually or with Astro.redirect.

```
Astro.redirect
```

The example below looks up an ID in the database on a dynamic page and either it returns a 404 if the product does not exist, or it redirects the user to another page if the product is no longer available, or it displays the product:

```
---
export const prerender = false; // Not needed in 'server' mode


import { getProduct } from '../api';


const product = await getProduct(Astro.params.id);


// No product found
if (!product) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found'
  });
}


// The product is no longer available
if (!product.isAvailable) {
  return Astro.redirect("/products", 301);
}
---
<html>
  <!-- Page here... -->
</html>
```

```
---
export const prerender = false; // Not needed in 'server' mode


import { getProduct } from '../api';


const product = await getProduct(Astro.params.id);


// No product found
if (!product) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found'
  });
}


// The product is no longer available
if (!product.isAvailable) {
  return Astro.redirect("/products", 301);
}
---
<html>
  <!-- Page here... -->
</html>
```

### Request

```
Request
```

Astro.request is a standard Request object. It can be used to get the url, headers, method, and even the body of the request.

```
Astro.request
```

```
url
```

```
headers
```

```
method
```

You can access additional information from this object for pages that are not statically generated.

#### Astro.request.headers

```
Astro.request.headers
```

The headers for the request are available on Astro.request.headers. This works like the browser’s Request.headers. It is a Headers object where you can retrieve headers such as the cookie.

```
Astro.request.headers
```

```
Request.headers
```

```
---
export const prerender = false; // Not needed in 'server' mode


const cookie = Astro.request.headers.get('cookie');
// ...
---
<html>
  <!-- Page here... -->
</html>
```

```
---
export const prerender = false; // Not needed in 'server' mode


const cookie = Astro.request.headers.get('cookie');
// ...
---
<html>
  <!-- Page here... -->
</html>
```

#### Astro.request.method

```
Astro.request.method
```

The HTTP method used in the request is available as Astro.request.method. This works like the browser’s Request.method. It returns the string representation of the HTTP method used in the request.

```
Astro.request.method
```

```
Request.method
```

```
---
export const prerender = false; // Not needed in 'server' mode


console.log(Astro.request.method) // GET (when navigated to in the browser)
---
```

```
---
export const prerender = false; // Not needed in 'server' mode


console.log(Astro.request.method) // GET (when navigated to in the browser)
---
```

See more details about Astro.request in the API reference.

```
Astro.request
```

### Server Endpoints

A server endpoint, also known as an API route, is a special function exported from a .js or .ts file within the src/pages/ folder. A powerful feature of server-side rendering on demand, API routes are able to securely execute code on the server.

```
.js
```

```
.ts
```

```
src/pages/
```

The function takes an endpoint context and returns a Response.

To learn more, see our Endpoints Guide.

## Learn Astro with James Q Quick

Build your first site with 35 interactive Scrimba lessons

